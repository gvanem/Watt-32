@ifndef BORLAND WATCOM DJGPP HIGHC VISUALC LADSOFT MINGW32 MINGW64 CYGWIN32 CYGWIN64 PELLESC LCC CLANG

  This is a master makefile that will generate all makefiles.  A makefile
  for a particular system is generated by passing this through the standalone
  executable:
     ..\util\mkmake       - on plain DOS.
     ..\util\win32\mkmake - on Windows.
     ..\util\linux\mkmake - on Linux.

  For example, to produce a makefile suitable for Watcom and small model use:

      ..\util\mkmake makefile.all WATCOM SMALL > watcom_s.mak

  Currently supported compilers include:

     BORLAND, WATCOM, DJGPP, HIGHC, VISUALC, MINGW32, MINGW64, CYGWIN32, CYGWIN64, PELLESC, LCC, CLANG

  Supported memory models and targets include:

     SMALL, LARGE, FLAT, WIN32, WIN64, DEBUG, RELEASE, SMALL32

  Some 32-bit DOS compilers can define these DOS-extender targets:

     PHARLAP, X32VM, DOS4GW    (otherwise all 32-bit DOS targets are FLAT)

  WATCOM wmake notes:
     A few restriction for WATCOM 'wmake' code exist if processed by 'mkmake utility':
       - To use '\' character literaly it must be followed by some character or space.
         If it is used as last character on the line then it is used as concatenation line character
       - If 'wmake' line start with '@' character, then tab character must be used on start of line
         to separate it from 'mkmake' directive line which start with '@' character too.
         But they can have only leading spaces

@else
#
# NB! THIS MAKEFILE WAS AUTOMATICALLY GENERATED FROM Makefile.all.
#     DO NOT EDIT. Edit Makefile.all and run "configur.bat" <target> instead.
#
# Makefile for the Watt-32 TCP/IP stack.
#

@ifdef VISUALC BORLAND LADSOFT LCC
!if "$(W32_BIN2C)" == ""
!error "'W32_BIN2C' is not defined. Try running 'configur.bat <target>' again."
!endif
@endif

@ifdef HIGHC DJGPP MINGW32 MINGW64 CYGWIN32 CYGWIN64 CLANG
ifeq ($(W32_BIN2C_),)
  $(error 'W32_BIN2C_' is not defined. Try running 'configur.bat <target>' again.)
endif
@endif

@ifdef WATCOM
!ifndef %W32_BIN2C
!error W32_BIN2C is not defined. Try running 'configur.bat watcom' again.
!endif
@endif

@ifdef BORLAND
!if "$(BCCDIR)" == ""
!error "'BCCDIR' is not defined. Do a 'set BCCDIR=root of you Borland (or CBuilder) install root'."
!endif
@endif

ASM_SOURCE = asmpkt.asm chksum0.asm cpumodel.asm

CORE_SOURCE = bsdname.c  btree.c    chksum.c   country.c  crc.c      dynip.c    \
              echo.c     fortify.c  getopt.c   gettod.c   highc.c    idna.c     \
              ip4_frag.c ip4_in.c   ip4_out.c  ip6_in.c   ip6_out.c  language.c \
              lookup.c   loopback.c misc.c     netback.c  oldstuff.c packet32.c \
              pc_cbrk.c  pcarp.c    pcbootp.c  pcbuf.c    pcconfig.c pcdbug.c   \
              pcdhcp.c   pcdns.c    pcicmp.c   pcicmp6.c  pcigmp.c   pcintr.c   \
              pcping.c   pcpkt.c    pcpkt32.c  pcqueue.c  pcrarp.c   pcrecv.c   \
              pcsed.c    pcstat.c   pctcp.c    ports.c    powerpak.c ppp.c      \
              pppoe.c    profile.c  punycode.c qmsg.c     rs232.c    run.c      \
              settod.c   sock_dbu.c sock_in.c  sock_ini.c sock_io.c  sock_prn.c \
              sock_scn.c sock_sel.c split.c    misc_str.c swsvpkt.c  tcp_fsm.c  \
              tcp_md5.c  tftp.c     timer.c    udp_rev.c  version.c  wdpmi.c    \
              win_dll.c  winadinf.c winmisc.c  winpkt.c   x32vm.c

BSD_SOURCE =  accept.c   bind.c     bsddbug.c  close.c    connect.c  fcntl.c    \
              fsext.c    get_ai.c   get_ip.c   get_ni.c   get_xbyr.c geteth.c   \
              gethost.c  gethost6.c getname.c  getnet.c   getprot.c  getput.c   \
              getserv.c  ioctl.c    linkaddr.c listen.c   netaddr.c  neterr.c   \
              nettime.c  nsapaddr.c poll.c     presaddr.c printk.c   receive.c  \
              select.c   shutdown.c signal.c   socket.c   sockopt.c  stream.c   \
              syslog.c   syslog2.c  transmit.c

BIND_SOURCE = res_comp.c res_data.c res_debu.c res_init.c res_loc.c res_mkqu.c \
              res_quer.c res_send.c

ZLIB_SOURCE = zadler32.c  zcompres.c zcrc32.c   zgzio.c \
              zuncompr.c  zdeflate.c ztrees.c   zutil.c \
              zinflate.c  zinfback.c zinftree.c zinffast.c

C_SOURCE = $(CORE_SOURCE) $(BSD_SOURCE) $(BIND_SOURCE) $(ZLIB_SOURCE)

COMMON_OBJS = \
@ifndef LCC CYGWIN64
       $(OBJPATH)chksum0.obj  $(OBJPATH)cpumodel.obj  \
@endif
       $(OBJPATH)accept.obj   $(OBJPATH)bind.obj      \
       $(OBJPATH)bsddbug.obj  $(OBJPATH)bsdname.obj   \
       $(OBJPATH)btree.obj    $(OBJPATH)chksum.obj    \
       $(OBJPATH)close.obj    $(OBJPATH)connect.obj   \
       $(OBJPATH)crc.obj      $(OBJPATH)dynip.obj     \
       $(OBJPATH)echo.obj     $(OBJPATH)fcntl.obj     \
       $(OBJPATH)fortify.obj  $(OBJPATH)get_ai.obj    \
       $(OBJPATH)get_ip.obj   $(OBJPATH)get_ni.obj    \
       $(OBJPATH)get_xbyr.obj $(OBJPATH)geteth.obj    \
       $(OBJPATH)gethost.obj  $(OBJPATH)gethost6.obj  \
       $(OBJPATH)getname.obj  $(OBJPATH)getnet.obj    \
       $(OBJPATH)getopt.obj   $(OBJPATH)getprot.obj   \
       $(OBJPATH)getput.obj   $(OBJPATH)getserv.obj   \
       $(OBJPATH)gettod.obj   $(OBJPATH)idna.obj      \
       $(OBJPATH)ioctl.obj    $(OBJPATH)ip4_frag.obj  \
       $(OBJPATH)ip4_in.obj   $(OBJPATH)ip4_out.obj   \
       $(OBJPATH)ip6_in.obj   $(OBJPATH)ip6_out.obj   \
       $(OBJPATH)language.obj $(OBJPATH)linkaddr.obj  \
       $(OBJPATH)listen.obj   $(OBJPATH)lookup.obj    \
       $(OBJPATH)loopback.obj $(OBJPATH)misc.obj      \
       $(OBJPATH)netaddr.obj  $(OBJPATH)netback.obj   \
       $(OBJPATH)neterr.obj   $(OBJPATH)nettime.obj   \
       $(OBJPATH)nsapaddr.obj $(OBJPATH)oldstuff.obj  \
       $(OBJPATH)packet32.obj $(OBJPATH)pc_cbrk.obj   \
       $(OBJPATH)pcarp.obj    $(OBJPATH)pcbootp.obj   \
       $(OBJPATH)pcbuf.obj    $(OBJPATH)pcconfig.obj  \
       $(OBJPATH)pcdbug.obj   $(OBJPATH)pcdhcp.obj    \
       $(OBJPATH)pcdns.obj    $(OBJPATH)pcicmp.obj    \
       $(OBJPATH)pcicmp6.obj  $(OBJPATH)pcigmp.obj    \
       $(OBJPATH)pcping.obj   $(OBJPATH)pcqueue.obj   \
       $(OBJPATH)pcrarp.obj   $(OBJPATH)pcrecv.obj    \
       $(OBJPATH)pcsed.obj    $(OBJPATH)pcstat.obj    \
       $(OBJPATH)pctcp.obj    $(OBJPATH)poll.obj      \
       $(OBJPATH)ports.obj    $(OBJPATH)ppp.obj       \
       $(OBJPATH)pppoe.obj    $(OBJPATH)presaddr.obj  \
       $(OBJPATH)printk.obj   $(OBJPATH)profile.obj   \
       $(OBJPATH)punycode.obj $(OBJPATH)receive.obj   \
       $(OBJPATH)res_comp.obj $(OBJPATH)res_data.obj  \
       $(OBJPATH)res_debu.obj $(OBJPATH)res_init.obj  \
       $(OBJPATH)res_loc.obj  $(OBJPATH)res_mkqu.obj  \
       $(OBJPATH)res_quer.obj $(OBJPATH)res_send.obj  \
       $(OBJPATH)run.obj      $(OBJPATH)select.obj    \
       $(OBJPATH)settod.obj   $(OBJPATH)shutdown.obj  \
       $(OBJPATH)signal.obj   $(OBJPATH)sock_dbu.obj  \
       $(OBJPATH)sock_in.obj  $(OBJPATH)sock_ini.obj  \
       $(OBJPATH)sock_io.obj  $(OBJPATH)sock_prn.obj  \
       $(OBJPATH)sock_scn.obj $(OBJPATH)sock_sel.obj  \
       $(OBJPATH)socket.obj   $(OBJPATH)sockopt.obj   \
       $(OBJPATH)split.obj    $(OBJPATH)stream.obj    \
       $(OBJPATH)misc_str.obj $(OBJPATH)swsvpkt.obj   \
       $(OBJPATH)syslog.obj   $(OBJPATH)syslog2.obj   \
       $(OBJPATH)tcp_fsm.obj  $(OBJPATH)tcp_md5.obj   \
       $(OBJPATH)tftp.obj     $(OBJPATH)timer.obj     \
       $(OBJPATH)transmit.obj $(OBJPATH)udp_rev.obj   \
       $(OBJPATH)version.obj  $(OBJPATH)zadler32.obj  \
       $(OBJPATH)zcompres.obj $(OBJPATH)zcrc32.obj    \
       $(OBJPATH)zdeflate.obj $(OBJPATH)zgzio.obj     \
       $(OBJPATH)zinfback.obj $(OBJPATH)zinffast.obj  \
       $(OBJPATH)zinflate.obj $(OBJPATH)zinftree.obj  \
       $(OBJPATH)ztrees.obj   $(OBJPATH)zuncompr.obj  \
       $(OBJPATH)zutil.obj

WINDOWS_OBJS = $(OBJPATH)win_dll.obj  \
               $(OBJPATH)winadinf.obj \
               $(OBJPATH)winmisc.obj  \
               $(OBJPATH)winpkt.obj

#
# These object are only possible for DOS (16/32-bit).
# So never add them to Library programs for Windows targets.
#
# This is to prevent warnings like these from MSVC's link:
#   qmsg.obj : warning LNK4221: This object file does not define any previously undefined public
#              symbols, so it will not be used by any link operation that consumes this library
#

DOS_OBJS = \
@ifdef SMALL LARGE
           $(OBJPATH)asmpkt.obj   \
@endif
           $(OBJPATH)country.obj  \
           $(OBJPATH)fsext.obj    \
           $(OBJPATH)pcpkt32.obj  \
           $(OBJPATH)pcpkt.obj    \
           $(OBJPATH)pcintr.obj   \
           $(OBJPATH)powerpak.obj \
           $(OBJPATH)qmsg.obj     \
           $(OBJPATH)rs232.obj    \
           $(OBJPATH)wdpmi.obj    \
           $(OBJPATH)x32vm.obj

#
# CPU, bit-width and suffix.
# Not used for any DOS targets.
#
@ifdef WIN64
CPU    = x64
BITS   = 64
SUFFIX = _64
@else
CPU    = x86
BITS   = 32
SUFFIX =
@endif

@ifdef WIN32 WIN64
#
# For all 32/64-bit Windows targets:
#
OBJS = $(COMMON_OBJS) $(WINDOWS_OBJS)

@ifdef VISUALC
OBJS = $(OBJS) $(OBJPATH)stkwalk.obj
@endif

@ifdef CLANG
OBJS += $(OBJPATH)stkwalk.obj
@endif

@else
#
# For all 16/32-bit DOS targets:
#
OBJS = $(COMMON_OBJS) $(DOS_OBJS)
@endif

@ifdef FLAT SMALL32
#
# This generated file is used for all 32-bit MSDOS targets
# (and when USE_FAST_PKT is defined). This enables a faster real-mode
# callback for the PKTDRVR receiver. Included as an array in pcpkt2.c.
#
PKT_STUB = pkt_stub.h
@endif

########################################################################

@ifdef DJGPP
#
# Only used by 'make -f djgpp install':
#
prefix = /dev/env/DJDIR/net/watt

ifeq ($(OS),Windows_NT)
  ifneq ($(DJ_PREFIX),)
    #
    # Windows hosted djgpp cross compiler. Get it from:
    #   https://github.com/andrewwutw/build-djgpp/releases  - djgpp-mingw-gcc*.zip
    #
    # and install to e.g. 'c:/djgpp/contrib'.
    # And then define an env-var:
    #   DJ_PREFIX=c:/djgpp/contrib/win-cross/bin/i586-pc-msdosdjgpp-
    #
    # Thus the full path to 'gcc' becomes:
    #   $(DJ_PREFIX)gcc.exe
    #
    # If not building on Windows, the '$(BIN_PREFIX)gcc' should simply become
    # 'gcc' and GNU-make should find that on %PATH.
    #
    BIN_PREFIX = $(DJ_PREFIX)

    ifeq ($(wildcard $(BIN_PREFIX)gcc.exe),)
      $(error Failed to find 'i586-pc-msdosdjgpp-gcc.exe'.)
    endif
  endif
else
  BIN_PREFIX =
endif

CFLAGS = -O3 -g -I. -I../inc -DWATT32_BUILD -W -Wall -Wno-strict-aliasing \
         -march=i386 -mtune=i586

#
# This is handy warning:
#
CFLAGS += -Wmissing-prototypes

ifeq ($(filter 2 3 4,$(word 3, $(shell true | $(CC) -E -dD -x c - | grep 'define\ *__GNUC__'))),)
  # We have gcc >= 5.x and we must ensure that always traditional
  # GNU extern inline semantics are used (aka -fgnu89-inline) even
  # if ISO C99 semantics have been specified.
  CFLAGS += -fgnu89-inline
endif

TARGET = ../lib/libwatt.a
OBJDIR = build/djgpp
OBJPATH = $(OBJDIR)/

CC     = $(BIN_PREFIX)gcc
AR     = $(BIN_PREFIX)ar rs
AS     = $(BIN_PREFIX)as
AFLAGS = # --gdwarf2

OBJS := $(subst .obj,.o,$(OBJS))

C_ARGS   = $(OBJPATH)gcc.arg
LIB_ARGS = $(OBJPATH)ar.arg

all: $(C_ARGS) $(PKT_STUB) $(OBJPATH)cflags.h $(TARGET)
	@echo All done

$(TARGET): $(OBJS) $(LIB_ARGS)
	$(AR) $@ @$(LIB_ARGS)

$(OBJPATH)%.o: %.c
	$(CC) -c @$(C_ARGS) -o $@ $<

$(OBJPATH)%.o: %.S
	$(CC) -E @$(C_ARGS) $< > $(OBJPATH)$*.iS
	$(AS) $(AFLAGS) $(OBJPATH)$*.iS -o $@

$(OBJPATH)chksum0.o:  chksum0.S
$(OBJPATH)cpumodel.o: cpumodel.S

clean:
	rm -f $(TARGET) $(OBJPATH)*.o $(OBJPATH)*.iS $(OBJPATH)*.arg $(PKT_STUB) $(OBJPATH)cflags.h
	@echo Cleaning done

install: all
	- mkdir -p "$(prefix)/inc"
	- mkdir -p "$(prefix)/lib"
	cp -fr ../inc "$(prefix)"
	cp -fr ../lib "$(prefix)"
	@echo Install to $(prefix) done

-include $(OBJPATH)watt32.dep

########################################################################

@elifdef BORLAND

@ifdef SMALL
CC      = bcc
CFLAGS  = -ms -H -H=$(TEMP)\bcc_s.pch -f- -Z
AFLAGS  = -mx -m2 -t -l
TARGET  = ..\lib\wattcpbs.lib
OBJDIR  = build\borland\small
MAKEFIL = bcc_s.mak

@elifdef LARGE
CC      = bcc
CFLAGS  = -ml -H -H=$(TEMP)\bcc_l.pch -f- -Z
AFLAGS  = -mx -m2 -t -l
TARGETS = ..\lib\wattcpbl.lib
OBJDIR  = build\borland\large
MAKEFIL = bcc_l.mak

@elifdef FLAT
CC      = bcc32
CFLAGS  = -4- -RT- -O2 -WX -f- -Z -H -H=$(TEMP)\bcc_f.pch
AFLAGS  = -mx -m2 -t -l -DDOSX
TARGETS = ..\lib\wattcpbf.lib
OBJDIR  = build\borland\flat
MAKEFIL = bcc_f.mak

@elifdef WIN32
#
# Since CBuilder 10 (I think), the 32-bit compiler is based on LLVM and
# it's name changed from 'bcc32.exe' to 'bcc32c.exe'.
# Ditto for 'cpp32.exe'  (the C/C++ preprocessor).
#
# Borland is now a product of "Embarcadero Technologies, Inc."
#
# Change the 'bcc32c' back to 'bcc32' to suite your version of CBuilder.
# Or create an env-var "CBUILDER_IS_LLVM_BASED=1".
#
!if "$(CBUILDER_IS_LLVM_BASED)" == ""
  CC     = $(BCCDIR)\bin\bcc32
  CPP    = $(BCCDIR)\bin\cpp32

  #
  # -5:  Use Pentium instructions.
  # -WM: Create Windows application.
  # -Vd: Virtual table control, disable
  # -H:  Use pre-compiled headers. '-H=xx' names the file.
  #
  CFLAGS = -5 -WM -Vd -H -H=$(TEMP)\bcc_w.pch

  #
  # Borland's Resource Compiler:
  #
  BRC32 = $(BCCDIR)\bin\brc32
!else
  CC     = $(BCCDIR)\bin\bcc32c
  CPP    = $(BCCDIR)\bin\cpp32c
  CFLAGS = # -fcolor-diagnostics-
  BRC32  = $(BCCDIR)\bin\rc -nologo
!endif

#
# -RT-: Generate RTTI, disable
#
CFLAGS = $(CFLAGS) -RT-

#
# Hacks for compiling the generated lang.c file:
#  Since CBuilder defines '__STDC_VERSION__', and Flex emits a "#include <inttypes.h>"
#  if 'FLEXINT_H' is not defined and '__STDC_VERSION__' is '>= 199901L'.
#  But no Borland version I have seen do have '<inttypes.h>'.
#
CFLAGS  = $(CFLAGS) -DFLEXINT_H -Dflex_int32_t=int -Dflex_int16_t=short

AFLAGS  = -mx -m2 -t -l -DDOSX
TARGETS = ..\lib\wattcpbw.lib ..\lib\wattcpbw_imp.lib ..\bin\watt-32.dll
OBJDIR  = build\borland\win32
MAKEFIL = bcc_w.mak

@else
!error Unknown BORLAND model
@endif

OBJPATH = $(OBJDIR)\ #

C_ARGS  = $(OBJPATH)bcc.arg

!if "$(CBUILDER_IS_LLVM_BASED)" == ""
  CFLAGS = $(CFLAGS) -w-aus- -w-pia- -w-csu-
!endif

CFLAGS = $(CFLAGS) -c -O -v -vi- -d -Tt -w  -I. -I..\inc -n$(OBJDIR) -DWATT32_BUILD

# CFLAGS = $(CFLAGS) -a-

AS = tasm32

LDFLAGS = -tWD -M -q -lr -lq -laa

#
# In case there is another implib.exe ahead of Borland's implib.exe.
# $(BCCDIR) -> root of Borland's (or CBuilder's) install root.
#
IMPLIB = $(BCCDIR)\bin\implib

.SWAP

all: $(PKT_STUB) $(C_ARGS) $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

..\lib\wattcpbs.lib: $(OBJS)
	$(BCCDIR)\bin\tlib ..\lib\wattcpbs.lib /C /E @&&|
	  -+$(OBJS:.obj=-+)
|
	- @del ..\lib\wattcpbs.bak

..\lib\wattcpbl.lib: $(OBJS)
	$(BCCDIR)\bin\tlib ..\lib\wattcpbl.lib /C /E /P32 @&&|
	  -+$(OBJS:.obj=-+)
|
	- @del ..\lib\wattcpbl.bak

..\lib\wattcpbf.lib: $(OBJS)
	$(BCCDIR)\bin\tlib ..\lib\wattcpbf.lib /C /E /P32 @&&|
	  -+$(OBJS:.obj=-+)
|
	- @del ..\lib\wattcpbf.bak

..\lib\wattcpbw.lib: $(OBJS)
	$(BCCDIR)\bin\tlib ..\lib\wattcpbw.lib /C /E /P64 @&&|
	  -+$(OBJS:.obj=-+)
|
	- @del ..\lib\wattcpbw.bak

..\lib\wattcpbw_imp.lib: ..\bin\watt-32.dll

..\bin\watt-32.dll: $(OBJS) $(OBJPATH)watt-32.res $(OBJPATH)objects.arg
	- @del ..\bin\watt-32.dll
	- @del ..\lib\wattcpbw_imp.lib
	$(CC) $(LDFLAGS) -e..\bin\watt-32.dll @$(OBJPATH)objects.arg
	$(BCCDIR)\bin\implib ..\lib\wattcpbw_imp.lib ..\bin\watt-32.dll
	- @del ..\bin\watt-32.tds
	@echo

clean:
	- @del $(OBJPATH)*.obj
	- @del $(OBJPATH)*.asm
	- @del $(OBJPATH)*.res
	- @del $(OBJPATH)*.arg
	- @del asmpkt.lst
	- @del $(TARGETS)
	- @del $(TEMP)\bcc_?.pch
	- @del pkt_stub.h
	@echo Cleaning done

$(OBJPATH)objects.arg: $(MAKEFIL)
	@copy &&|
	 $(OBJS) $(OBJPATH)watt-32.res
| $(OBJPATH)objects.arg

$(C_ARGS): $(MAKEFIL)
	@copy &&|
	  $(CFLAGS)
| $<

$(OBJPATH)asmpkt.obj:   asmpkt.asm
$(OBJPATH)chksum0.obj:  chksum0.asm
$(OBJPATH)cpumodel.obj: cpumodel.asm

.c.obj:
	$(CC) -q @$(C_ARGS) $*.c

.c.i:
	$(CPP) -q @$(C_ARGS) $*.c

.asm.obj:
	$(AS) $(AFLAGS) $*.asm, $(OBJPATH)$*.obj

!include "build\borland\watt32.dep"

########################################################################

@elifdef WATCOM

.ERASE

.EXTENSIONS: .l

@ifdef SMALL
CC      = *wcc
CFLAGS  = -ms -0 -os -zc -s -zlf -bt=dos
AFLAGS  = -bt=dos
TARGET  = ..\lib\wattcpws.lib
OBJDIR  = build\watcom\small

@elifdef LARGE
CC      = *wcc
CFLAGS  = -ml -0 -os -zc -s -zlf -bt=dos
AFLAGS  = -bt=dos
TARGET  = ..\lib\wattcpwl.lib
OBJDIR  = build\watcom\large

@elifdef FLAT
CC      = *wcc386
CFLAGS  = -mf -3r -zff -zgf -zm -s -zlf -bt=dos -oilrtfm # -I$(%PHARLAP)\include
AFLAGS  = -bt=dos -3r -dDOSX -dDOS4GW
TARGET  = ..\lib\wattcpwf.lib
OBJDIR  = build\watcom\flat

@elifdef WIN32
CC       = *wcc386
CFLAGS   = -mf -3r -zm -bd -bm -d3 -zlf -bt=nt -fp6 -oilrtfm -zri
AFLAGS   = -bt=nt -3s -dDOSX
LDFLAGS  = system nt dll
TARGET   = ..\lib\wattcpww.lib ..\lib\wattcpww_imp.lib
WATTDLL  = ..\bin\watt-32.dll
OBJDIR   = build\watcom\win32
RESOURCE = $(OBJPATH)watt-32.res

@elifdef SMALL32
CC      = *wcc386
CFLAGS  = -ms -oaxt -s -zlf -bt=dos
AFLAGS  = -3 -bt=dos -dDOSX
TARGET  = ..\lib\wattcpw3.lib
OBJDIR  = build\watcom\small32

@else
!error Unknown WATCOM model
@endif

OBJPATH = $(OBJDIR)\ #

LIBARG  = $(OBJPATH)wlib.arg
LINKARG = $(OBJPATH)wlink.arg
C_ARGS  = $(OBJPATH)wcc.arg

AFLAGS += -zq -fr=nul -w3 -d1
CFLAGS += -zq -fr=nul -wx -fpi

#
# Since Watcom's internal (?) 'echo' sometimes fails to handle so many arguments in
# the 'cflags.h' rule below.
#
EXTRA_CFLAGS = -DWATT32_BUILD -I. -I..\inc -I$(%WATCOM)\h

#
# WCC386-flags used:
#   -m{s,l,f} memory model; small, large or flat
#   -3s       optimise for 386, stack call convention
#   -3r       optimise for 386, register calls
#   -s        no stack checking
#   -zq       quiet compiling
#   -d3       generate full debug info
#   -fpi      inline math + emulation
#   -fr       write errors to file (and stdout)
#   -bt=dos   target system - DOS
#   -bt=nt    target system - Win-NT
#   -zlf      always generate default library information
#   -zm       place each function in separate segment
#   -oilrtfm  optimization flags
#     i:      expand intrinsics
#     l:      loop optimisations
#     r:      reorder instructions
#     t:      favor execution time
#     f:      always use stack frames
#     m:      generate inline code for math functions
#
#  This should make the smallest code on a 386
#    -oahkrs -s -em -zp1 -3r -fp3
#
#  WCC-flags for small/large model:
#    -zc      place const data into the code segment
#    -os      optimization flags
#      s:     favour code size over execution time
#

AS = *wasm
AR = *wlib -q -b -c

all: $(PKT_STUB) $(C_ARGS) $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGET)

@ifdef WIN32
$(WATTDLL) ..\lib\wattcpww_imp.lib: $(OBJS) $(RESOURCE) $(LINKARG)
	*wlink $(LDFLAGS) name $(WATTDLL) @$(LINKARG)
@endif

..\lib\wattcpww.lib: $(OBJS) $(LIBARG)
	$(AR) -p=1024 $^@ @$(LIBARG)

..\lib\wattcpws.lib: $(OBJS) $(LIBARG)
	$(AR) $^@ @$(LIBARG)

..\lib\wattcpwl.lib: $(OBJS) $(LIBARG)
	$(AR) $^@ @$(LIBARG)

..\lib\wattcpwf.lib: $(OBJS) $(LIBARG)
	$(AR) $^@ @$(LIBARG)

..\lib\wattcpw3.lib: $(OBJS) $(LIBARG)
	$(AR) $^@ @$(LIBARG)

-!include "build\watcom\watt32.dep"

$(OBJPATH)asmpkt.obj:   asmpkt.asm
$(OBJPATH)chksum0.obj:  chksum0.asm
$(OBJPATH)cpumodel.obj: cpumodel.asm

.c{$(OBJDIR)}.obj:
	$(CC) $[@ @$(C_ARGS) -fo=$@

.asm{$(OBJDIR)}.obj:
	$(AS) $[@ $(AFLAGS) -fo=$@

$(C_ARGS): $(__MAKEFILES__)
	%create $^@
	%append $^@ $(CFLAGS) $(EXTRA_CFLAGS)

clean: .SYMBOLIC
	- @del $(OBJPATH)*.obj
	- @del $(OBJPATH)cflags.h
	- @del $(OBJPATH)cflagsbf.h
	- @del $(TARGET)
	- @del $(C_ARGS)
	- @del $(LIBARG)
@ifdef WIN32
	- @del $(LINKARG)
	- @del $(WATTDLL)
	- @del $(RESOURCE)
	- @del ..\bin\watt-32.map
@else
	- @del pkt_stub.h
@endif
	@echo Cleaning done

$(LIBARG): $(__MAKEFILES__)
	%create $^@
	@for %f in ($(OBJS)) do @%append $^@ +- %f

@ifdef WIN32
$(LINKARG): $(__MAKEFILES__)
	%create $^@
	@%append $^@ option implib=..\lib\wattcpww_imp.lib, quiet, map, verbose,
	@%append $^@ caseexact, map=..\bin\watt-32.map, res=$(RESOURCE)
	@%append $^@ file { $(OBJS) }
@endif

########################################################################

@elifdef VISUALC

#
# A perculiar feature (or bug?) with the MS linker is that the import
# libs (..\lib\$(CPU)\wattcpvc_imp.lib + ..\lib\$(CPU)\wattcpvc_imp_d.lib) can get
# older than the target .dll they represent. Hence the below 'touch'
# commands.
#
# Special <crtdefs.h> defines:
#  _CRT_SECURE_NO_WARNINGS
#  _CRT_SECURE_NO_DEPRECATE
#  _CRT_SECURE_NO_WARNINGS_GLOBALS
#  _CRT_NONSTDC_NO_WARNINGS
#  _CRT_OBSOLETE_NO_WARNINGS
#
# Note: 'cdecl' (-Gd) is default. Check if '__fastcall' (-Gr) in '_DEBUG' mode
#       is possible.
#
# The Microsoft Macro Assembler (ml and ml64) is available here:
#   http://www.microsoft.com/en-us/download/details.aspx?id=12654
#
CFLAGS = -nologo -Zi -W3 -DWATT32_BUILD -D_WIN32_WINNT=0x0601 -I. -I../inc

LDFLAGS = -machine:$(CPU)

#
# Do not use the so called "POSIX supplemented" error-codes.
# They are of little use since a 'strerror(x)' always returns
# "unknown error" for these.
#
# CFLAGS = $(CFLAGS) -D_CRT_NO_POSIX_ERROR_CODE

@ifdef DEBUG
CFLAGS = $(CFLAGS) -MDd -Ot -D_DEBUG -EHsc -RTCc -RTCs -RTCu -GF -GS # -Gr
@else
CFLAGS = $(CFLAGS) -MD -Ox -GS- # -Gr
@endif

@ifdef WIN64
AS     = ml64
AFLAGS = -c -nologo -DDOSX -DWIN64 -Zi
@else
#
# WIN32
#
AS     = ml
AFLAGS = -c -nologo -DDOSX -Zi -coff
@endif

@ifdef DEBUG
TARGETS = ..\lib\$(CPU)\wattcpvc_d.lib ..\lib\$(CPU)\wattcpvc_imp_d.lib ..\bin\watt-32d$(SUFFIX).dll
OBJDIR  = build\visualc\$(BITS)bit\debug
MAKEFIL = visualc-debug_$(BITS).mak

@else
TARGETS = ..\lib\$(CPU)\wattcpvc.lib ..\lib\$(CPU)\wattcpvc_imp.lib ..\bin\watt-32$(SUFFIX).dll
OBJDIR  = build\visualc\$(BITS)bit\release
MAKEFIL = visualc-release_$(BITS).mak
@endif

OBJPATH = $(OBJDIR)\ #

CC      = cl
LDFLAGS = -dll -nologo -map -debug -debugtype:cv -incremental:no -verbose $(LDFLAGS)

#
# The 'lib' command common to MSVC: Win32/Win64
#
AR = lib -nologo -ignore:4221

#
# Ignore warning:
#   xyz.obj : warning LNK4221: This object file does not define any previously undefined
#   public symbols, so it will not be used by any link operation that consumes this library
#
# May not be supported by all 'link' versions.
#
LDFLAGS = $(LDFLAGS) -ignore:4221

#
# Enable the watt-32.dll to be used on Win-XP SP3 (5.2) in case
# it was built under Win-Vista+
#
LDFLAGS   = $(LDFLAGS) -subsystem:console,5.02

EX_LIBS   = user32.lib advapi32.lib
RESOURCE  = $(OBJPATH)watt-32.res
C_ARGS    = $(OBJPATH)cl.arg
LINK_ARGS = $(OBJPATH)link.arg

all: $(C_ARGS) $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

$(C_ARGS): $(MAKEFIL)
	@echo $(CFLAGS) > $@

$(LINK_ARGS): $(MAKEFIL)
	@echo $(OBJS) $(RESOURCE) $(EX_LIBS) > $@

#
# Static libs
#
..\lib\$(CPU)\wattcpvc.lib: $(OBJS)
	$(AR) -machine:$(CPU) -out:$@ @<<
	 $**
<<

..\lib\$(CPU)\wattcpvc_d.lib: $(OBJS)
	$(AR) -machine:$(CPU) -out:$@ @<<
	 $**
<<

#
# Import libs + DLLs
#
..\bin\watt-32$(SUFFIX).dll ..\lib\$(CPU)\wattcpvc_imp.lib: $(OBJS) $(RESOURCE) $(LINK_ARGS)
	link $(LDFLAGS) -out:..\bin\watt-32$(SUFFIX).dll -implib:..\lib\$(CPU)\wattcpvc_imp.lib @$(LINK_ARGS) > link.tmp
	type link.tmp >> ..\bin\watt-32$(SUFFIX).map
	@del ..\lib\$(CPU)\wattcpcvc_imp.exp
	touch ../lib/$(CPU)/wattcpvc_imp.lib

..\bin\watt-32d$(SUFFIX).dll ..\lib\$(CPU)\wattcpvc_imp_d.lib: $(OBJS) $(RESOURCE) $(LINK_ARGS)
	link $(LDFLAGS) -out:..\bin\watt-32d$(SUFFIX).dll -implib:..\lib\$(CPU)\wattcpvc_imp_d.lib @$(LINK_ARGS) > link.tmp
	type link.tmp >> ..\bin\watt-32d$(SUFFIX).map
	@del ..\lib\$(CPU)\wattcpcvc_imp_d.exp
	touch ../lib/$(CPU)/wattcpvc_imp_d.lib

clean:
	- @del $(TARGETS)
	- @del $(C_ARGS) $(LINK_ARGS)
	- @del $(OBJPATH)*.obj $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h
	- @del $(OBJPATH)*.lst
	- @del $(RESOURCE)
	- @del vc1*.pdb ..\lib\x86\wattcpcvc_*.exp ..\lib\x64\wattcpcvc_*.exp ..\bin\watt-32$(SUFFIX).pdb ..\bin\watt-32d$(SUFFIX).pdb
	@echo Cleaning done

$(OBJPATH)chksum0.obj:  chksum0.asm
$(OBJPATH)cpumodel.obj: cpumodel.asm

.cpp{$(OBJDIR)}.obj:
	$(CC) -c @$(C_ARGS) -EHsc -Fo.\$*.obj $<

.c{$(OBJDIR)}.obj:
	$(CC) -c @$(C_ARGS) -Fo.\$*.obj $<

.asm{$(OBJDIR)}.obj:
	$(AS) $(AFLAGS) -Fo.\$*.obj -Fl.\$*.lst $<

!include build\visualc\watt32.dep

########################################################################

@elifdef LCC

@ifndef WIN32
!error The only possible target for LCC is WIN32
@endif

CC      = lcc
CFLAGS  = -g2 -O -A -I. -I../inc -DWATT32_BUILD
OBJDIR  = build\lcc
TARGETS = ..\lib\wattcp_lcc.lib ..\lib\wattcp_lcc_imp.lib ..\bin\watt-32.dll
MAKEFIL = lcc.mak
OBJPATH = $(OBJDIR)\ #

AS       = tasm32
AFLAGS   = -DDOSX -mx -m2 -t -l
LDFLAGS  = -subsystem console -dll -dynamic
EX_LIBS  = user32.lib advapi32.lib
RESOURCE = $(OBJPATH)watt-32.res

all: $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

..\lib\wattcp_lcc.lib: $(OBJS)
	@echo Generating ..\lib\wattcp_lcc.lib ...
	@cd $(OBJDIR)
	@for %f in (*.obj) do lcclib ..\..\lib\wattcp_lcc.lib %f
	@cd ..

#
# Import lib + DLL (debug)
#
..\bin\watt-32.dll ..\lib\wattcp_lcc_imp.lib: $(OBJS)
	lcclnk $(LDFLAGS) -o ..\bin\watt-32.dll -map watt-32.map $(OBJS) $(EX_LIBS)
	implib ..\lib\wattcp_lcc_imp.lib ..\bin\watt-32.dll

clean:
	- @del $(TARGETS)
	- @del $(OBJPATH)*.obj
	- @del $(OBJPATH)cflagsbf.h
	- @del $(RESOURCE)
	- @del *.lst
	@echo Cleaning done

$(OBJPATH)chksum0.obj:  chksum0.asm
$(OBJPATH)cpumodel.obj: cpumodel.asm

.c{$(OBJDIR)}.obj:
	$(CC) -c $(CFLAGS) -o $*.obj $<

.asm{$(OBJDIR)}.obj:
	$(AS) $(AFLAGS) $<, $*.obj

!include $(OBJPATH)watt32.dep

########################################################################

@elifdef CLANG

CC     = clang-cl
CFLAGS = -nologo -Zi -Zo -GS- -I. -I../inc \
         -DWATT32_BUILD                    \
         -D_CRT_SECURE_NO_WARNINGS         \
         -D_CRT_NONSTDC_NO_WARNINGS        \
         -D_CRT_OBSOLETE_NO_WARNINGS       \
         -D_WIN32_WINNT=0x0601             \
         -D_WINSOCK_DEPRECATED_NO_WARNINGS \
         -DBUILD_WINDOWS

CFLAGS += -Wno-\#pragma-messages

#
# This is handy warning:
#
CFLAGS += -Wmissing-prototypes

@ifdef DEBUG
  CFLAGS += -MDd
@else
  CFLAGS += -MD -Ox
@endif

#
# Enable full Microsoft Visual C++ compatibility
#
CFLAGS += -fms-compatibility
LDFLAGS = -dll -nologo -map -debug -debugtype:cv -incremental:no -verbose

#
# The 'lib' command common to Win32/Win64
#
AR = lib -nologo

#
# Ignore warning:
#   xyz.obj : warning LNK4221: This object file does not define any previously undefined
#   public symbols, so it will not be used by any link operation that consumes this library
#
# May not be supported by all 'lib' and 'link' versions.
#
LDFLAGS += -ignore:4221
AR      += -ignore:4221

#
# Enable the watt-32.dll to be used on Win-XP SP3 (5.2) in case
# it was built under Win-Vista+
#
LDFLAGS += -subsystem:console,5.02

EX_LIBS  = user32.lib advapi32.lib
RESOURCE = $(OBJPATH)watt-32.res

@ifdef DEBUG
TARGETS = ../lib/$(CPU)/wattcp_clang_d.lib ../lib/$(CPU)/wattcp_clang_imp_d.lib ../bin/watt-32$(SUFFIX)d.dll
OBJDIR  = build/clang/$(BITS)bit/debug
@else
TARGETS = ../lib/$(CPU)/wattcp_clang.lib ../lib/$(CPU)/wattcp_clang_imp.lib ../bin/watt-32$(SUFFIX).dll
OBJDIR  = build/clang/$(BITS)bit/release
@endif

OBJPATH = $(OBJDIR)/

@ifdef WIN64
  AS     = ml64
  AFLAGS = -c -nologo -DDOSX -Zi -DWIN64
@else
  AS     = ml
  AFLAGS = -c -nologo -DDOSX -Zi -coff
@endif

C_ARGS    = $(OBJPATH)clang.arg
LIB_ARGS  = $(OBJPATH)lib.arg
LINK_ARGS = $(OBJPATH)link.arg

#
# In case '%CL%' is set, it may confuse 'clang-cl'. Unset it.
#
export CL=

all: $(C_ARGS) $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

#
# Static library rules:
#
../lib/$(CPU)/wattcp_clang_d.lib: $(OBJS) $(LIB_ARGS)
	$(AR) -machine:$(CPU) -out:$@ @$(LIB_ARGS)

../lib/$(CPU)/wattcp_clang.lib: $(OBJS) $(LIB_ARGS)
	$(AR) -machine:$(CPU) -out:$@  @$(LIB_ARGS)

#
# Import lib + DLLs (release, debug)
#
../lib/$(CPU)/wattcp_clang_imp.lib:   ../bin/watt-32$(SUFFIX).dll
../lib/$(CPU)/wattcp_clang_imp_d.lib: ../bin/watt-32$(SUFFIX)d.dll

../bin/watt-32$(SUFFIX).dll: $(OBJS) $(RESOURCE) $(LINK_ARGS)
	link $(LDFLAGS) -machine:$(CPU) -out:$@ -implib:../lib/$(CPU)/wattcp_clang_imp.lib @$(LINK_ARGS) > link.tmp
	cat link.tmp >> ../bin/watt-32$(SUFFIX).map
	rm -f ../lib/$(CPU)/wattcp_clang_imp.exp

../bin/watt-32$(SUFFIX)d.dll: $(OBJS) $(RESOURCE) $(LINK_ARGS)
	link $(LDFLAGS) -machine:$(CPU) -out:$@ -implib:../lib/$(CPU)/wattcp_clang_imp_d.lib @$(LINK_ARGS) > link.tmp
	cat link.tmp >> ../bin/watt-32$(SUFFIX)d.map
	rm -f ../lib/$(CPU)/wattcp_clang_imp_d.exp

clean:
	- rm -f $(TARGETS) $(OBJPATH)*.obj $(OBJPATH)*.arg $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(RESOURCE)
	@echo Cleaning done

$(OBJPATH)%.obj: %.c
	$(CC) -c @$(C_ARGS) -Fo./$@ $<

$(OBJPATH)%.obj: %.cpp
	$(CC) -c -TP -EHsc @$(C_ARGS) -Fo./$@ $<

$(OBJPATH)%.obj: %.asm
	$(AS) $(AFLAGS) -Fo./$@ -Fl./$(OBJDIR)/$*.lst $<

include build/clang/watt32.dep

########################################################################

@elifdef HIGHC
#
# Using HighC with GNU-make
#
OBJDIR  = build/highc
OBJDIR_ = build\highc
TARGET  = ../lib/wattcphf.lib
MAKEFIL = highc.mak
OBJPATH = $(OBJDIR)/

CC     = hc386
C_ARGS = $(OBJDIR)/highc.arg

CFLAGS = -I. -I../inc -I$(PHARLAP)/include -w3 -g -O2 -DWATT32_BUILD \
         -Hpentium_only -DBUGGY_FARPTR=1 -Hnocopyr -Hnoswap          \
         -Hon=relax_func_ptr_rules -Hon=Preload_args_from_memory     \
         -Hon=char_is_rep -Hon=quiet -Hoff=check_stack               \
         -Hon=Recognize_library -Hon=Align_labels -Hoff=Call_trace   \
         -Hpragma=stack_size_warn(10000) -Hoff=Prolog_trace          \
         -Hoff=Epilog_trace -Hpragma=Offwarn(257)                    \
         -Hpragma=Offwarn(572) -Hpragma=Offwarn(578) -Hpragma=Offwarn(491)

AS     = tasm32
AFLAGS = -DDOSX -mx -m2 -t -l
AR     = 386lib -nobanner

all: $(PKT_STUB) $(C_ARGS) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h $(TARGET)
	@echo All done

$(TARGET): $(OBJS)
	@echo -nowarn -nobackup -twocase -pagesize 32 > $(OBJDIR)/lib.arg
	@echo -replace $(OBJS)                       >> $(OBJDIR)/lib.arg
	$(AR) $(TARGET) @$(OBJDIR)/lib.arg

clean:
	rm -f $(TARGET) $(OBJDIR)/*.obj $(OBJDIR)/*.arg $(OBJDIR)/*.h chksum0.lst cpumodel.lst $(PKT_STUB)
	@echo Cleaning done

$(OBJDIR)/chksum0.obj: chksum0.asm
	$(AS) $(AFLAGS) $<, $(OBJDIR_)\chksum0.obj

$(OBJDIR)/cpumodel.obj: cpumodel.asm
	$(AS) $(AFLAGS) $<, $(OBJDIR_)\cpumodel.obj

$(OBJDIR)/%.obj: %.c
	$(CC) -c @$(C_ARGS) -o $@ $<

include $(OBJDIR)/watt32.dep

########################################################################

@elifdef LADSOFT

CC      = cc386
CFLAGS  = -I. -I..\inc +v -O+a -O+i -C+N -DWATT32_BUILD
AR      = xlib
AS      = tasm32
AFLAGS  = -DDOSX -DDOS4GW -mx -m2 -t -l
OBJDIR  = build\ladsoft
MAKEFIL = ladsoft.mak
TARGET  = ..\lib\wattcplf.lib
OBJPATH = $(OBJDIR)\ #

.SWAP

all: $(PKT_STUB) $(OBJPATH)cflagsbf.h $(TARGET)
	@echo All done

$(TARGET): $(OBJS)
	$(AR) $(TARGET) @$(OBJPATH)xlib.rsp
	- @del $(TARGET:.lib=.bak)

clean:
	- @del $(OBJPATH)*.obj
	- @del $(OBJPATH)*.asm
	- @del $(OBJPATH)*.lst
	- @del $(TARGET)
	- @del pkt_stub.h
	@echo Cleaning done

$(OBJPATH)chksum0.obj:  chksum0.asm
$(OBJPATH)cpumodel.obj: cpumodel.asm

.c.obj:
	$(CC) -c $(CFLAGS) $*.c -o$(OBJPATH)$*.asm
	$(W32_NASM) -s -f obj -l $(OBJPATH)$*.lst -o $(OBJPATH)$*.obj $(OBJPATH)$*.asm

.asm.obj:
	$(AS) $(AFLAGS) $*.asm, $(OBJPATH)$*.obj

!include "build\ladsoft\watt32.dep"

########################################################################

@elifdef MINGW32

CC      = gcc
CFLAGS  = -O2 -g -Wall -Wno-strict-aliasing -mthreads -pipe -I. -I../inc \
          -DWATT32_BUILD -D_WIN32_WINNT=0x0601 -DWINVER=0x0601

LDFLAGS = -shared -Wl,--enable-stdcall-fixup,--print-map,--sort-common,--cref

#
# gcc/as debug formats:
#
CFLAGS += -gstabs
AFLAGS += -gstabs

#
# In the case where 'MinGW32.mak' file is erroneously used to
# build a 64-bit Watt-32 DLL (using e.g. TDM-gcc's "dual-mode" gcc).
# Since in MinGW-w64, 'gcc' w/o '-m32', will generate 64-bit code,
# the result from this makefile is '../bin/watt-32.dll'. And not
# '../bin/watt-32_64.dll'. To build for MinGW-w64 or TDM-gcc, use
# one of these commands:
#   make -f MinGW64_32.mak
#   make -f MinGW64_64.mak
#
# If your gcc/ld/as bundled with the old-school MinGW is too old,
# comment away the '-m32' + '--32' below.
#
CFLAGS  += -m$(BITS)
LDFLAGS += -m$(BITS)
AFLAGS  += --$(BITS)

#
# Just a test
#
CFLAGS += -std=c99

AS       = as
AR       = ar rs
TARGETS  = ../lib/libwatt32.a ../lib/libwatt32.dll.a ../bin/watt-32.dll
OBJDIR   = build/MinGW32
OBJPATH  = $(OBJDIR)/
RESOURCE = $(OBJDIR)/watt-32.res

OBJS := $(subst .obj,.o,$(OBJS))

C_ARGS    = $(OBJDIR)/gcc.arg
LIB_ARGS  = $(OBJDIR)/ar.arg
LINK_ARGS = $(OBJDIR)/ld.arg

all: $(C_ARGS) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h $(TARGETS)
	@echo All done

../lib/libwatt32.a: $(OBJS) $(LIB_ARGS)
	$(AR) $@ @$(LIB_ARGS)

../lib/libwatt32.dll.a: ../bin/watt-32.dll

../bin/watt-32.dll: $(OBJS) $(RESOURCE) $(LINK_ARGS)
	$(CC) $(LDFLAGS) -Wl,--out-implib,../lib/libwatt32.dll.a -o $@ @$(LINK_ARGS) > ../bin/watt-32.map

$(OBJDIR)/chksum0.o:  chksum0.S
$(OBJDIR)/cpumodel.o: cpumodel.S

$(OBJDIR)/%.o: %.c
	$(CC) -c @$(C_ARGS) -o $@ $<

$(OBJDIR)/%.o: %.S
	$(CC) -E @$(C_ARGS) $< > $(OBJDIR)/$*.iS
	$(AS) $(AFLAGS) $(OBJDIR)/$*.iS -o $@

clean:
	rm -f $(TARGETS) $(OBJDIR)/*.o $(OBJDIR)/*.iS $(OBJDIR)/*.arg $(RESOURCE) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h
	@echo Cleaning done

-include $(OBJDIR)/watt32.dep

########################################################################

@elifdef MINGW64

NO_OPT ?= 0
CC      = gcc

ifeq ($(NO_OPT),0)
  CFLAGS = -O2 -g -gstabs
else
  #
  # 'make NO_OPT=1 -f *.mak' -> tests gcc 5.x with no optimisations
  #                             and old-style inlining.
  #
  CFLAGS = -O0 -g2 -fgnu89-inline
endif

CFLAGS += -Wall -Wundef -Wno-strict-aliasing -I. -I../inc -DWATT32_BUILD -D_WIN32_WINNT=0x0601 -DWINVER=0x0601
LDFLAGS = -shared -Wl,--enable-stdcall-fixup,--print-map,--sort-common,--cref

#
# configur.bat + mkmake.exe generates 2 makefiles for MINGW64:
#  * for 32-bit programs, use MinGW64_32.mak.
#  * for 64-bit programs, use MinGW64_64.mak.
#
# I have tested TDM-gcc [1] only. [2] may work here too. (And
# there are other MinGW64 packages too).
# For TDM-gcc, 64-bit programs is the default (unless '-m32' is used).
#
# [1] http://tdm-gcc.tdragon.net/
# [2] http://mingw-w64.sourceforge.net/
#
# And the 'PATH' must have been setup to choose the correct 'gcc.exe'.
#
TARGETS = ../lib/$(CPU)/libwatt32.a ../lib/$(CPU)/libwatt32.dll.a ../bin/watt-32$(SUFFIX).dll

OBJDIR   = build/MinGW64/$(BITS)bit
OBJPATH  = $(OBJDIR)/
CFLAGS  += -m$(BITS)
LDFLAGS += -m$(BITS)
AFLAGS  += --$(BITS) -gstabs

AS       = as
AR       = ar rs
RESOURCE = $(OBJDIR)/watt-32.res
EX_LIBS  =

OBJS := $(subst .obj,.o,$(OBJS))

C_ARGS    = $(OBJDIR)/gcc.arg
LIB_ARGS  = $(OBJDIR)/ar.arg
LINK_ARGS = $(OBJDIR)/ld.arg

all: $(C_ARGS) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h $(TARGETS)
	@echo All done

../lib/$(CPU)/libwatt32.a: $(OBJS) $(LIB_ARGS)
	$(AR) $@ @$(LIB_ARGS)

../lib/$(CPU)/libwatt32.dll.a: ../bin/watt-32$(SUFFIX).dll

../bin/watt-32$(SUFFIX).dll: $(OBJS) $(RESOURCE) $(LINK_ARGS)
	$(CC) $(LDFLAGS) -Wl,--out-implib,../lib/$(CPU)/libwatt32.dll.a -o $@ @$(LINK_ARGS) > ../bin/watt-32$(SUFFIX).map

$(OBJDIR)/chksum0.o:  chksum0.S
$(OBJDIR)/cpumodel.o: cpumodel.S

$(OBJDIR)/%.o: %.c
	$(CC) -c @$(C_ARGS) -o $@ -c $<

$(OBJDIR)/%.o: %.S
	$(CC) -E @$(C_ARGS) $< > $(OBJDIR)/$*.iS
	$(AS) $(AFLAGS) $(OBJDIR)/$*.iS -o $@

clean:
	rm -f $(TARGETS) $(OBJDIR)/*.arg $(OBJDIR)/*.o $(OBJDIR)/*.iS $(RESOURCE) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h
	@echo Cleaning done

-include $(OBJDIR)/watt32.dep

########################################################################

@elifdef CYGWIN32 CYGWIN64

CC       = gcc
CFLAGS   = -m$(BITS) -O2 -g -Wall -mthreads -fno-strict-aliasing -static-libgcc -I. -I../inc -DWATT32_BUILD
LDFLAGS  = -m$(BITS) -shared -static-libgcc
AS       = as
AFLAGS   = --$(BITS) -ahls

AR       = ar rs
TARGETS  = ../lib/(CPU)/libwatt32-cygwin.a ../lib/$(CPU)/libwatt32-cygwin.dll.a ../bin/watt-32$(SUFFIX).dll
OBJDIR   = ./build/CygWin/$(BITS)bit
OBJPATH  = $(OBJDIR)/
RESOURCE = $(OBJDIR)/watt-32.res

ifeq ($(CPU),x86)
  LDFLAGS += -Wl,--enable-stdcall-fixup
endif

OBJS := $(subst .obj,.o,$(OBJS))

C_ARGS    = $(OBJDIR)/gcc.arg
LIB_ARGS  = $(OBJDIR)/ar.arg
LINK_ARGS = $(OBJDIR)/ld.arg

all: $(C_ARGS) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h $(TARGETS)
	@echo All done

../lib/$(CPU)/libwatt32-cygwin.a: $(OBJS) $(LIB_ARGS)
	$(AR) $@ @$(LIB_ARGS)

../lib/(CPU)/libwatt32-cygwin.dll.a: ../bin/watt-32.dll

../bin/watt-32.dll: $(OBJS) $(RESOURCE) $(LINK_ARGS)
	$(CC) $(LDFLAGS) -Wl,--out-implib,../lib/(CPU)/libwatt32-cygwin.dll.a -o $@ @$(LINK_ARGS)

$(OBJDIR)/chksum0.o:  chksum0.S
$(OBJDIR)/cpumodel.o: cpumodel.S

$(OBJDIR)/%.o: %.c
	$(CC) -c @$(C_ARGS) -o $@ $<

$(OBJDIR)/%.o: %.S
	$(CC) -E @$(C_ARGS) $< > $(OBJDIR)/$*.iS
	$(AS) $(AFLAGS) $(OBJDIR)/$*.iS -o $@

clean:
	rm -f $(TARGETS) $(OBJDIR)/*.o $(OBJDIR)/*.iS $(OBJDIR)/*.arg $(RESOURCE) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h
	@echo Cleaning done

-include $(OBJDIR)/watt32.dep

########################################################################

@elifdef PELLESC

CFLAGS  = -T$(CPU)-coff
LDFLAGS = -machine:$(CPU)

@ifdef WIN64
AS      = ml64
AFLAGS  = -DDOSX -DWIN64
WINLIB  = $(PELLESC)\lib\Win64
@else
AS      = ml
AFLAGS  = -DDOSX -DWIN32 -coff
WINLIB  = $(PELLESC)\lib\Win
@endif

MAKEFIL = pellesc_$(BITS).mak
OBJDIR  = build\pellesc\$(BITS)bit
OBJPATH = $(OBJDIR)\ #

CC      = pocc
CFLAGS  = $(CFLAGS) -DWATT32_BUILD -MT -X -Ox -Ob1 -Ze -Zi -W1 -Go \
          -I$(PELLESC)\include -I$(PELLESC)\include\win -I. -I..\inc # -std:C99

AFLAGS  = -c -nologo -Zi $(AFLAGS)

TARGETS = ..\lib\$(CPU)\wattcppo.lib ..\lib\$(CPU)\wattcppo_imp.lib ..\bin\watt-32$(SUFFIX).dll

RESOURCE = $(OBJPATH)watt-32.res
LDFLAGS  = $(LDFLAGS) -dll -map -libpath:$(PELLESC)\lib -libpath:$(WINLIB) -subsystem:console -debug -verbose
EX_LIBS  = user32.lib kernel32.lib advapi32.lib

all: $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

..\lib\$(CPU)\wattcppo.lib: $(OBJS)
	polib -out:$@ $**

..\bin\watt-32$(SUFFIX).dll ..\lib\$(CPU)\wattcppo_imp.lib: $(OBJS) $(RESOURCE)
	polink $(LDFLAGS) -out:..\bin\watt-32$(SUFFIX).dll -implib:..\lib\$(CPU)\wattcppo_imp.lib \
           $** $(EX_LIBS) > link.tmp
	type link.tmp >> ..\bin\watt-32$(SUFFIX).map

clean:
	- @del $(TARGETS) $(RESOURCE)
	- @del $(OBJPATH)*.obj $(OBJPATH)*.lst $(OBJPATH)cflagsbf.h
	@echo Cleaning done

$(OBJPATH)chksum0.obj:  chksum0.asm
$(OBJPATH)cpumodel.obj: cpumodel.asm

.c{$(OBJDIR)}.obj:
	$(CC) -c $(CFLAGS) -Fo$*.obj $<

.asm{$(OBJDIR)}.obj:
	$(AS) $(AFLAGS) -Fo $*.obj -Fl $(OBJPATH)$*.lst $<

!include build\pellesc\watt32.dep

@endif

########################################################################

doxygen:
	doxygen doxyfile

lang.c: lang.l
	flex -8 -t lang.l > lang.c

@ifdef HIGHC DJGPP MINGW32 MINGW64 CLANG CYGWIN32 CYGWIN64 CLANG
  #
  # All these Windows targets uses GNU-make. Hence it should be safe to
  # assume the 'date' program is available.
  #
  DATE = $(shell date +%d-%B-%Y)

  #
  # Create a response file $(1).
  # One word from $(2) per line into $(1).
  #
  define create_response_file
    $(file > $(1))
    $(foreach f, $(2), $(file >> $(1),$(strip $(f))) )
  endef

$(C_ARGS): $(MAKEFILE_LIST)
	$(call create_response_file, $@, $(CFLAGS))

$(LIB_ARGS): $(OBJS) $(MAKEFILE_LIST)
	$(call create_response_file, $@, $(OBJS))

$(LINK_ARGS): $(OBJS) $(RESOURCE)
	$(call create_response_file, $@, $^ $(EX_LIBS))

  #
  # GNU-Make rules uses shell 'sh' commands:
  #
$(OBJDIR)/cflags.h: $(MAKEFILE_LIST)
	echo 'const char *w32_cflags = "$(CFLAGS)";' > $(OBJDIR)/cflags.h
	echo 'const char *w32_cc     = "$(CC)";'    >> $(OBJDIR)/cflags.h

@elifdef WATCOM
$(OBJDIR)/cflags.h: $(__MAKEFILES__)
!ifdef __UNIX__
	echo 'const char *w32_cflags = "$(CFLAGS)";' > $(OBJDIR)/cflags.h
	echo 'const char *w32_cc     = "$(CC)";'    >> $(OBJDIR)/cflags.h
!else
	echo const char *w32_cflags = '"$(CFLAGS)";' > $(OBJPATH)cflags.h
	echo const char *w32_cc     = '"$(CC)";'    >> $(OBJPATH)cflags.h
!endif

@elifdef BORLAND
$(OBJPATH)cflags.h: $(MAKEFIL)
	echo const char *w32_cflags = '"$(CFLAGS)";' > $(OBJPATH)cflags.h
	echo const char *w32_cc     = '"$(CC)";'    >> $(OBJPATH)cflags.h

@else
#
# This is for tools which could possibly not handle all the arguments in
# the 'CFLAGS'. We to do this in several steps creating a multiline string
# for 'w32_cflags'!
#
$(OBJPATH)cflags.h: $(MAKEFIL)
	echo const char *w32_cflags =       > $(OBJPATH)cflags.h
	echo            "$(CFLAGS)"        >> $(OBJPATH)cflags.h
	echo            "$(EXTRA_CFLAGS);" >> $(OBJPATH)cflags.h
	echo const char *w32_cc = "$(CC)"; >> $(OBJPATH)cflags.h
@endif

@ifdef DJGPP HIGHC
$(OBJDIR)/pcpkt.obj: asmpkt.nas
$(OBJDIR)/pcpkt.o:   asmpkt.nas

$(PKT_STUB): asmpkt.nas
	$(W32_NASM_) -f bin -l asmpkt.lst -o asmpkt.bin asmpkt.nas
	$(W32_BIN2C_) asmpkt.bin > $@

@elifdef FLAT SMALL32
$(OBJPATH)pcpkt.obj: asmpkt.nas

@ifdef WATCOM
$(PKT_STUB): asmpkt.nas
	$(%W32_NASM) -f bin -l asmpkt.lst -o asmpkt.bin asmpkt.nas
	$(%W32_BIN2C) asmpkt.bin > $@

@else
$(PKT_STUB): asmpkt.nas
	$(W32_NASM) -f bin -l asmpkt.lst -o asmpkt.bin asmpkt.nas
	$(W32_BIN2C) asmpkt.bin > $@
@endif

@endif  # FLAT

build\Borland\Win32\watt-32.res: watt-32.rc
	$(BRC32) -DDEBUG=0 -D__BORLANDC__ -r -i..\inc -fo build\Borland\Win32\watt-32.res watt-32.rc

build/clang/32bit/release/watt-32.res: watt-32.rc
	rc -nologo -DRC_DATE="$(DATE)" -DDEBUG=0 -D__clang__ -DBITS=32 -Fo build/clang/32bit/release/watt-32.res watt-32.rc

build/clang/32bit/debug/watt-32.res: watt-32.rc
	rc -nologo -DRC_DATE="$(DATE)" -DDEBUG=1 -D__clang__ -DBITS=32 -Fo build/clang/32bit/debug/watt-32.res watt-32.rc

build/clang/64bit/release/watt-32.res: watt-32.rc
	rc -nologo -DRC_DATE="$(DATE)" -DDEBUG=0 -D__clang__ -DBITS=64 -Fo build/clang/64bit/release/watt-32.res watt-32.rc

build/clang/64bit/debug/watt-32.res: watt-32.rc
	rc -nologo -DRC_DATE="$(DATE)" -DDEBUG=1 -D__clang__ -DBITS=64 -Fo build/clang/64bit/debug/watt-32.res watt-32.rc

build\lcc\watt-32.res: watt-32.rc
	lrc -DDEBUG=0 -D__LCC__ -i..\inc -obuild\lcc\watt-32.res watt-32.rc

build/MinGW32/watt-32.res: watt-32.rc
	windres -DRC_DATE="$(DATE)" --target=pe-i386 -D__MINGW32__ -DDEBUG=0 -O coff -o $@ -i watt-32.rc

build/MinGW64/32bit/watt-32.res: watt-32.rc
	windres -DRC_DATE="$(DATE)" -DBITS=32 --target=pe-i386 -D__MINGW64__ -DDEBUG=0 -O coff -o $@ -i watt-32.rc

build/MinGW64/64bit/watt-32.res: watt-32.rc
	windres -DRC_DATE="$(DATE)" -DBITS=64 --target=pe-x86-64 -D__MINGW64__ -DDEBUG=0 -O coff -o $@ -i watt-32.rc

build/CygWin/32bit/watt-32.res: watt-32.rc
	windres -DRC_DATE="$(DATE)" -DBITS=32 -I../inc -DDEBUG=0 -D__CYGWIN__ -O coff -o $@ -i watt-32.rc

build/CygWin/64bit/watt-32.res: watt-32.rc
	windres -DRC_DATE="$(DATE)" -DBITS=64 -I../inc -DDEBUG=0 -D__CYGWIN__ -O coff -o $@ -i watt-32.rc

build\pellesc\32bit\watt-32.res: watt-32.rc
	porc -DDEBUG=0 -D__POCC__ -DBITS=32 -I..\inc -Fobuild\pellesc\32bit\watt-32.res watt-32.rc

build\pellesc\64bit\watt-32.res: watt-32.rc
	porc -DDEBUG=0 -D__POCC__ -DBITS=64 -I..\inc -Fobuild\pellesc\64bit\watt-32.res watt-32.rc

build\visualc\32bit\release\watt-32.res: watt-32.rc
	rc -nologo -DDEBUG=0 -D_MSC_VER -DBITS=32 -Fo build\visualc\32bit\release\watt-32.res watt-32.rc

build\visualc\32bit\debug\watt-32.res: watt-32.rc
	rc -nologo -DDEBUG=1 -D_MSC_VER -DBITS=32 -Fo build\visualc\32bit\debug\watt-32.res watt-32.rc

build\visualc\64bit\release\watt-32.res: watt-32.rc
	rc -nologo -DDEBUG=0 -D_MSC_VER -DBITS=64 -Fo build\visualc\64bit\release\watt-32.res watt-32.rc

build\visualc\64bit\debug\watt-32.res: watt-32.rc
	rc -nologo -DDEBUG=1 -D_MSC_VER -DBITS=64 -Fo build\visualc\64bit\debug\watt-32.res watt-32.rc

build\watcom\win32\watt-32.res: watt-32.rc
	*wrc -dDEBUG=0 -D__WATCOMC__ -q -r -zm -fo=build\watcom\win32\watt-32.res watt-32.rc

#
# Rules for creating 'cflagsbf.h'. A file with a C-array of the 'CFLAGS' used.
# Included in 'version.c'.
#
# $(W32_BIN2C) should be set by .\configur.bat to point to either
# ..\util\bin2c.exe or ..\util\win32\bin2c.exe.
#
# And for GNU-make, $(W32_BIN2C_) should be set by .\configur.bat to point to either
# ../util/bin2c.exe or ../util/win32/bin2c.exe.
#
# PS. 'cflagsbf.h' was previously named 'cflags_buf.h'. But that may cause troubles
#     on plain DOS with only 8+3 files.
#
build\build\borland\small\cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS)                     > build\borland\small\cflagsbf.h

build\borland\large\cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS)                     > build\borland\large\cflagsbf.h

build\borland\flat\cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS)                     > build\borland\flat\cflagsbf.h

build\borland\win32\cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS)                     > build\borland\win32\cflagsbf.h

build\ladsoft\cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C)            - > build\ladsoft\cflagsbf.h

build\lcc\cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C)            - > build\lcc\cflagsbf.h

build\pellesc\32bit\cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C)            - > build\pellesc\32bit\cflagsbf.h

build\pellesc\64bit\cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C)            - > build\pellesc\64bit\cflagsbf.h

build\visualc\32bit\release\cflagsbf.h:
	- echo $(CFLAGS) | $(W32_BIN2C)          - > build\visualc\32bit\release\cflagsbf.h

build\visualc\32bit\debug\cflagsbf.h:
	- echo $(CFLAGS) | $(W32_BIN2C)          - > build\visualc\32bit\debug\cflagsbf.h

build\visualc\64bit\release\cflagsbf.h:
	- echo $(CFLAGS) | $(W32_BIN2C)          - > build\visualc\64bit\release\cflagsbf.h

build\visualc\64bit\debug\cflagsbf.h:
	- echo $(CFLAGS) | $(W32_BIN2C)          - > build\visualc\64bit\debug\cflagsbf.h

@ifdef HIGHC DJGPP MINGW32 MINGW64 CYGWIN32 CYGWIN64
#
# Nmake doesn't like these rules. Hence inside this block.
#
build/CygWin/32bit/cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C_)           - > build/CygWin/32bit/cflagsbf.h

build/CygWin/64bit/cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C_)           - > build/CygWin/64bit/cflagsbf.h

build/MinGW32/cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C_)           - > build/MinGW32/cflagsbf.h

build/MinGW64/32bit/cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C_)           - > build/MinGW64/32bit/cflagsbf.h

build/MinGW64/64bit/cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C_)           - > build/MinGW64/64bit/cflagsbf.h

build/highc/cflagsbf.h:
	echo "$(CFLAGS)" | $(W32_BIN2C_)         - > build/highc/cflagsbf.h

@elifdef WATCOM
build\watcom\small\cflagsbf.h: $(C_ARGS)
	$(%W32_BIN2C) $(C_ARGS)                    > build\watcom\small\cflagsbf.h

build\watcom\large\cflagsbf.h: $(C_ARGS)
	$(%W32_BIN2C) $(C_ARGS)                    > build\watcom\large\cflagsbf.h

build\watcom\flat\cflagsbf.h: $(C_ARGS)
	$(%W32_BIN2C) $(C_ARGS)                    > build\watcom\flat\cflagsbf.h

build\watcom\win32\cflagsbf.h: $(C_ARGS)
	$(%W32_BIN2C) $(C_ARGS)                    > build\watcom\win32\cflagsbf.h

build\watcom\small32\cflagsbf.h: $(C_ARGS)
	$(%W32_BIN2C) $(C_ARGS)                    > build\watcom\small32\cflagsbf.h

@elifdef CLANG
build/clang/32bit/release/cflagsbf.h \
build/clang/32bit/debug/cflagsbf.h   \
build/clang/64bit/release/cflagsbf.h \
build/clang/64bit/debug/cflagsbf.h:
	$(W32_BIN2C_) $(C_ARGS) > $@
@endif

@ifdef HIGHC DJGPP MINGW32 MINGW64 CLANG CYGWIN32 CYGWIN64 CLANG

DEP_REPLACE = sed -e 's/\(.*\)\.o: /\n$$(OBJPATH)\1.o: /' \
                  -e 's@/cygdrive/@:@'

DEP_FILE = $(OBJDIR)/watt-32.dep

depend: $(OBJDIR)/cflags.h
	$(CC) -MM $(CFLAGS) $(C_SOURCE) | $(DEP_REPLACE) > $(DEP_FILE)

-include $(DEP_FILE)

@endif

