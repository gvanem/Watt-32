@ifndef BORLAND WATCOM DJGPP HIGHC VISUALC LADSOFT MINGW32 MINGW64 CYGWIN32 CYGWIN64 PELLESC LCC CLANG

  This is a master makefile that will generate all makefiles.  A makefile
  for a particular system is generated by passing this through the standalone
  DOS executable ..\util\mkmake. For example, to produce a makefile suitable
  for Watcom and small model use:

      ..\util\mkmake makefile.all WATCOM SMALL > watcom_s.mak

  Currently supported compilers include:

     BORLAND, WATCOM, DJGPP, HIGHC, VISUALC, MINGW32, MINGW64, CYGWIN32, CYGWIN64, PELLESC, LCC, CLANG

  Supported memory models and targets include:

     SMALL, LARGE, FLAT, WIN32, WIN64, DEBUG, RELEASE, SMALL32

  Some 32-bit DOS compilers can define these DOS-extender targets:

     PHARLAP, X32VM, DOS4GW    (otherwise all 32-bit DOS targets are FLAT)

@else
#
# NB! THIS MAKEFILE WAS AUTOMATICALLY GENERATED FROM Makefile.all.
#     DO NOT EDIT. Edit Makefile.all and run "configur.bat" <target> instead.
#
# Makefile for the Watt-32 TCP/IP stack.
#

@ifdef VISUALC HIGHC BORLAND LADSOFT LCC
!if "$(W32_BIN2C)" == ""
!error "'W32_BIN2C' is not defined. Try running 'configur.bat <target>' again."
!endif
@endif

@ifdef DJGPP MINGW32 MINGW64 CYGWIN32 CYGWIN64 CLANG
ifeq ($(W32_BIN2C_),)
  $(error 'W32_BIN2C_' is not defined. Try running 'configur.bat <target>' again.)
endif
@endif

@ifdef WATCOM
!ifndef %W32_BIN2C
!error W32_BIN2C is not defined. Try running 'configur.bat watcom' again.
!endif
@endif

@ifdef BORLAND
!if "$(BCCDIR)" == ""
!error "'BCCDIR' is not defined. Do a 'set BCCDIR=root of you Borland (or CBuilder) install root'."
!endif
@endif

ASM_SOURCE = asmpkt.asm chksum0.asm cpumodel.asm

CORE_SOURCE = bsdname.c  btree.c    chksum.c   country.c  crc.c      dynip.c    \
              echo.c     fortify.c  getopt.c   gettod.c   highc.c    idna.c     \
              ip4_frag.c ip4_in.c   ip4_out.c  ip6_in.c   ip6_out.c  language.c \
              lookup.c   loopback.c misc.c     netback.c  oldstuff.c packet32.c \
              pc_cbrk.c  pcarp.c    pcbootp.c  pcbuf.c    pcconfig.c pcdbug.c   \
              pcdhcp.c   pcdns.c    pcicmp.c   pcicmp6.c  pcigmp.c   pcintr.c   \
              pcping.c   pcpkt.c    pcpkt32.c  pcqueue.c  pcrarp.c   pcrecv.c   \
              pcsed.c    pcstat.c   pctcp.c    ports.c    powerpak.c ppp.c      \
              pppoe.c    profile.c  punycode.c qmsg.c     rs232.c    run.c      \
              settod.c   sock_dbu.c sock_in.c  sock_ini.c sock_io.c  sock_prn.c \
              sock_scn.c sock_sel.c split.c    strings.c  swsvpkt.c  tcp_fsm.c  \
              tcp_md5.c  tftp.c     timer.c    udp_rev.c  version.c  wdpmi.c    \
              win_dll.c  winadinf.c winmisc.c  winpkt.c   x32vm.c

BSD_SOURCE =  accept.c   bind.c     bsddbug.c  close.c    connect.c  fcntl.c    \
              fsext.c    get_ai.c   get_ip.c   get_ni.c   get_xbyr.c geteth.c   \
              gethost.c  gethost6.c getname.c  getnet.c   getprot.c  getput.c   \
              getserv.c  ioctl.c    linkaddr.c listen.c   netaddr.c  neterr.c   \
              nettime.c  nsapaddr.c poll.c     presaddr.c printk.c   receive.c  \
              select.c   shutdown.c signal.c   socket.c   sockopt.c  stream.c   \
              syslog.c   syslog2.c  transmit.c

BIND_SOURCE = res_comp.c res_data.c res_debu.c res_init.c res_loc.c res_mkqu.c \
              res_quer.c res_send.c

ZLIB_SOURCE = zadler32.c  zcompres.c zcrc32.c   zgzio.c \
              zuncompr.c  zdeflate.c ztrees.c   zutil.c \
              zinflate.c  zinfback.c zinftree.c zinffast.c

C_SOURCE = $(CORE_SOURCE) $(BSD_SOURCE) $(BIND_SOURCE) $(ZLIB_SOURCE)

COMMON_OBJS = \
@ifndef LCC CYGWIN64
       $(OBJDIR)\chksum0.obj  $(OBJDIR)\cpumodel.obj  \
@endif
       $(OBJDIR)\accept.obj   $(OBJDIR)\bind.obj      \
       $(OBJDIR)\bsddbug.obj  $(OBJDIR)\bsdname.obj   \
       $(OBJDIR)\btree.obj    $(OBJDIR)\chksum.obj    \
       $(OBJDIR)\close.obj    $(OBJDIR)\connect.obj   \
       $(OBJDIR)\crc.obj      $(OBJDIR)\dynip.obj     \
       $(OBJDIR)\echo.obj     $(OBJDIR)\fcntl.obj     \
       $(OBJDIR)\fortify.obj  $(OBJDIR)\get_ai.obj    \
       $(OBJDIR)\get_ip.obj   $(OBJDIR)\get_ni.obj    \
       $(OBJDIR)\get_xbyr.obj $(OBJDIR)\geteth.obj    \
       $(OBJDIR)\gethost.obj  $(OBJDIR)\gethost6.obj  \
       $(OBJDIR)\getname.obj  $(OBJDIR)\getnet.obj    \
       $(OBJDIR)\getopt.obj   $(OBJDIR)\getprot.obj   \
       $(OBJDIR)\getput.obj   $(OBJDIR)\getserv.obj   \
       $(OBJDIR)\gettod.obj   $(OBJDIR)\idna.obj      \
       $(OBJDIR)\ioctl.obj    $(OBJDIR)\ip4_frag.obj  \
       $(OBJDIR)\ip4_in.obj   $(OBJDIR)\ip4_out.obj   \
       $(OBJDIR)\ip6_in.obj   $(OBJDIR)\ip6_out.obj   \
       $(OBJDIR)\language.obj $(OBJDIR)\linkaddr.obj  \
       $(OBJDIR)\listen.obj   $(OBJDIR)\lookup.obj    \
       $(OBJDIR)\loopback.obj $(OBJDIR)\misc.obj      \
       $(OBJDIR)\netaddr.obj  $(OBJDIR)\netback.obj   \
       $(OBJDIR)\neterr.obj   $(OBJDIR)\nettime.obj   \
       $(OBJDIR)\nsapaddr.obj $(OBJDIR)\oldstuff.obj  \
       $(OBJDIR)\packet32.obj $(OBJDIR)\pc_cbrk.obj   \
       $(OBJDIR)\pcarp.obj    $(OBJDIR)\pcbootp.obj   \
       $(OBJDIR)\pcbuf.obj    $(OBJDIR)\pcconfig.obj  \
       $(OBJDIR)\pcdbug.obj   $(OBJDIR)\pcdhcp.obj    \
       $(OBJDIR)\pcdns.obj    $(OBJDIR)\pcicmp.obj    \
       $(OBJDIR)\pcicmp6.obj  $(OBJDIR)\pcigmp.obj    \
       $(OBJDIR)\pcping.obj   $(OBJDIR)\pcqueue.obj   \
       $(OBJDIR)\pcrarp.obj   $(OBJDIR)\pcrecv.obj    \
       $(OBJDIR)\pcsed.obj    $(OBJDIR)\pcstat.obj    \
       $(OBJDIR)\pctcp.obj    $(OBJDIR)\poll.obj      \
       $(OBJDIR)\ports.obj    $(OBJDIR)\ppp.obj       \
       $(OBJDIR)\pppoe.obj    $(OBJDIR)\presaddr.obj  \
       $(OBJDIR)\printk.obj   $(OBJDIR)\profile.obj   \
       $(OBJDIR)\punycode.obj $(OBJDIR)\receive.obj   \
       $(OBJDIR)\res_comp.obj $(OBJDIR)\res_data.obj  \
       $(OBJDIR)\res_debu.obj $(OBJDIR)\res_init.obj  \
       $(OBJDIR)\res_loc.obj  $(OBJDIR)\res_mkqu.obj  \
       $(OBJDIR)\res_quer.obj $(OBJDIR)\res_send.obj  \
       $(OBJDIR)\run.obj      $(OBJDIR)\select.obj    \
       $(OBJDIR)\settod.obj   $(OBJDIR)\shutdown.obj  \
       $(OBJDIR)\signal.obj   $(OBJDIR)\sock_dbu.obj  \
       $(OBJDIR)\sock_in.obj  $(OBJDIR)\sock_ini.obj  \
       $(OBJDIR)\sock_io.obj  $(OBJDIR)\sock_prn.obj  \
       $(OBJDIR)\sock_scn.obj $(OBJDIR)\sock_sel.obj  \
       $(OBJDIR)\socket.obj   $(OBJDIR)\sockopt.obj   \
       $(OBJDIR)\split.obj    $(OBJDIR)\stream.obj    \
       $(OBJDIR)\strings.obj  $(OBJDIR)\swsvpkt.obj   \
       $(OBJDIR)\syslog.obj   $(OBJDIR)\syslog2.obj   \
       $(OBJDIR)\tcp_fsm.obj  $(OBJDIR)\tcp_md5.obj   \
       $(OBJDIR)\tftp.obj     $(OBJDIR)\timer.obj     \
       $(OBJDIR)\transmit.obj $(OBJDIR)\udp_rev.obj   \
       $(OBJDIR)\version.obj  $(OBJDIR)\zadler32.obj  \
       $(OBJDIR)\zcompres.obj $(OBJDIR)\zcrc32.obj    \
       $(OBJDIR)\zdeflate.obj $(OBJDIR)\zgzio.obj     \
       $(OBJDIR)\zinfback.obj $(OBJDIR)\zinffast.obj  \
       $(OBJDIR)\zinflate.obj $(OBJDIR)\zinftree.obj  \
       $(OBJDIR)\ztrees.obj   $(OBJDIR)\zuncompr.obj  \
       $(OBJDIR)\zutil.obj

WINDOWS_OBJS = $(OBJDIR)\win_dll.obj  \
               $(OBJDIR)\winadinf.obj \
               $(OBJDIR)\winmisc.obj  \
               $(OBJDIR)\winpkt.obj

#
# These object are only possible for DOS (16/32-bit).
# So never add them to Library programs for Windows targets.
#
# This is to prevent warnings like these from MSVC's link:
#   qmsg.obj : warning LNK4221: This object file does not define any previously undefined public
#              symbols, so it will not be used by any link operation that consumes this library
#

DOS_OBJS = \
@ifdef SMALL LARGE
           $(OBJDIR)\asmpkt.obj   \
@endif
           $(OBJDIR)\country.obj  \
           $(OBJDIR)\fsext.obj    \
           $(OBJDIR)\pcpkt32.obj  \
           $(OBJDIR)\pcpkt.obj    \
           $(OBJDIR)\pcintr.obj   \
           $(OBJDIR)\powerpak.obj \
           $(OBJDIR)\qmsg.obj     \
           $(OBJDIR)\rs232.obj    \
           $(OBJDIR)\wdpmi.obj    \
           $(OBJDIR)\x32vm.obj

@ifdef WIN32 WIN64
#
# For all 32/64-bit Windows targets
#
OBJS = $(COMMON_OBJS) $(WINDOWS_OBJS)

@ifdef VISUALC
OBJS = $(OBJS) $(OBJDIR)\stkwalk.obj
@endif

@ifdef CLANG
OBJS += $(OBJDIR)/stkwalk.obj
@endif

@else
#
# For all 16/32-bit DOS targets
#
OBJS = $(COMMON_OBJS) $(DOS_OBJS)
@endif

#
# This generated file is used for all 32-bit MSDOS targets
# (and when USE_FAST_PKT is defined). This enables a faster real-mode
# callback for the PKTDRVR receiver. Included as an array in pcpkt2.c.
#
@ifdef FLAT SMALL32
PKT_STUB = pkt_stub.h
@endif

########################################################################

@ifdef DJGPP

ifeq ($(OS),Windows_NT)
  ifneq ($(DJ_PREFIX),)
    #
    # Windows hosted djgpp cross compiler. Get it from:
    #   https://github.com/andrewwutw/build-djgpp/releases
    #
    # Define an env-var 'DJ_PREFIX=f:/gv/djgpp/bin/i586-pc-msdosdjgpp-'
    # Thus the full path to 'gcc' becomes:
    #   $(DJ_PREFIX)gcc.exe
    #
    # If not building on Windows, the '$(BIN_PREFIX)gcc' should simply become
    # 'gcc' and GNU-make should find that on %PATH.
    #
    BIN_PREFIX = $(DJ_PREFIX)

    ifeq ($(wildcard $(BIN_PREFIX)gcc.exe),)
      $(error Failed to find 'i586-pc-msdosdjgpp-gcc.exe'.)
    endif
  endif
else
  BIN_PREFIX =
endif

CFLAGS = -O2 -g -I. -I../inc -DWATT32_BUILD -W -Wall -Wno-strict-aliasing

#
# This is handy warning:
#
CFLAGS += -Wmissing-prototypes

CC     = $(BIN_PREFIX)gcc
AS     = $(BIN_PREFIX)as
AR     = $(BIN_PREFIX)ar rs
AFLAGS = # --gdwarf2
TARGET = ../lib/libwatt.a
OBJDIR = build/djgpp

OBJS := $(subst \,/,$(OBJS))
OBJS := $(subst .obj,.o,$(OBJS))

all: $(PKT_STUB) $(OBJDIR)/cflags.h $(TARGET)
	@echo All done

$(TARGET): $(OBJS)
	$(AR) $@ $?

$(OBJDIR)/%.o: %.c
	$(CC) $(CFLAGS) -o $@ -c $<

$(OBJDIR)/%.o: %.S
	$(CC) -E $(CFLAGS) $< > $(OBJDIR)/$*.iS
	$(AS) $(AFLAGS) $(OBJDIR)/$*.iS -o $@

$(OBJDIR)/chksum0.o:  chksum0.S
$(OBJDIR)/cpumodel.o: cpumodel.S

clean:
	rm -f $(TARGET) $(OBJDIR)/*.o $(OBJDIR)/*.iS $(PKT_STUB) $(OBJDIR)/cflags.h
	@echo Cleaning done

-include $(OBJDIR)/watt32.dep

########################################################################

@elifdef BORLAND

@ifdef SMALL
CC      = bcc
CFLAGS  = -ms -H -H=$(TEMP)\bcc_s.pch -f- -Z
AFLAGS  = -mx -m2 -t -l
TARGET  = ..\lib\wattcpbs.lib
OBJDIR  = build\borland\small
C_ARGS  = $(OBJDIR)\bcc.arg
MAKEFIL = bcc_s.mak

@elifdef LARGE
CC      = bcc
CFLAGS  = -ml -H -H=$(TEMP)\bcc_l.pch -f- -Z
AFLAGS  = -mx -m2 -t -l
TARGETS = ..\lib\wattcpbl.lib
OBJDIR  = build\borland\large
C_ARGS  = $(OBJDIR)\bcc.arg
MAKEFIL = bcc_l.mak

@elifdef FLAT
CC      = bcc32
CFLAGS  = -4- -RT- -O2 -WX -f- -Z -H -H=$(TEMP)\bcc_f.pch
AFLAGS  = -mx -m2 -t -l -DDOSX
TARGETS = ..\lib\wattcpbf.lib
OBJDIR  = build\borland\flat
C_ARGS  = $(OBJDIR)\bcc32.arg
MAKEFIL = bcc_f.mak

@elifdef WIN32
#
# Since CBuilder 10 (I think), the 32-bit compiler is based on LLVM and
# it's name changed from 'bcc32.exe' to 'bcc32c.exe'.
# Ditto for 'cpp32.exe'  (the C/C++ preprocessor).
#
# Borland is now a product of "Embarcadero Technologies, Inc."
#
# Change the 'bcc32c' back to 'bcc32' to suite your version of CBuilder.
# Or create an env-var "CBUILDER_IS_LLVM_BASED=1".
#
!if "$(CBUILDER_IS_LLVM_BASED)" == ""
  CC     = $(BCCDIR)\bin\bcc32
  CPP    = $(BCCDIR)\bin\cpp32
  C_ARGS = $(OBJDIR)\bcc32.arg

  #
  # -5:  Use Pentiom instructions.
  # -WM: Create Windows application.
  # -Vd: Virtual table control, disable
  # -H:  Use pre-compiled headers. '-H=xx' names the file.
  #
  CFLAGS = -5 -WM -Vd -H -H=$(TEMP)\bcc_w.pch

  #
  # Borland's Resource Compiler:
  #
  BRC32 = $(BCCDIR)\bin\brc32
!else
  CC     = $(BCCDIR)\bin\bcc32c
  CPP    = $(BCCDIR)\bin\cpp32c
  C_ARGS = $(OBJDIR)\bcc32c.arg
  CFLAGS = # -fcolor-diagnostics-
  BRC32  = $(BCCDIR)\bin\rc -nologo
!endif

#
# -RT-: Generate RTTI, disable
#
CFLAGS  = $(CFLAGS) -RT-

#
# Hacks for compiling the generated lang.c file:
#  Since CBuilder defines '__STDC_VERSION__', and Flex emits a "#include <inttypes.h>"
#  if 'FLEXINT_H' is not defined and '__STDC_VERSION__' is '>= 199901L'.
#  But no Borland version I have seen do have '<inttypes.h>'.
#
CFLAGS  = $(CFLAGS) -DFLEXINT_H -Dflex_int32_t=int -Dflex_int16_t=short

AFLAGS  = -mx -m2 -t -l -DDOSX
TARGETS = ..\lib\wattcpbw.lib ..\lib\wattcpbw_imp.lib ..\bin\watt-32.dll
OBJDIR  = build\borland\win32
MAKEFIL = bcc_w.mak

@else
!error Unknown BORLAND model
@endif

!if "$(CBUILDER_IS_LLVM_BASED)" == ""
  CFLAGS = $(CFLAGS) -w-aus- -w-pia- -w-csu-
!endif

CFLAGS = $(CFLAGS) -c -O -v -vi- -d -Tt -w  -I. -I..\inc -n$(OBJDIR) -DWATT32_BUILD

# CFLAGS = $(CFLAGS) -a-

AS = tasm32

LDFLAGS = -tWD -M -q -lr -lq -laa

#
# In case there is another implib.exe ahead of Borland's implib.exe.
# $(BCCDIR) -> root of Borland's (or CBuilder's) install root.
#
IMPLIB = $(BCCDIR)\bin\implib

.SWAP

all: $(PKT_STUB) $(C_ARGS) $(OBJDIR)\cflags.h $(OBJDIR)\cflagsbf.h $(TARGETS)
	@echo All done

..\lib\wattcpbs.lib: $(OBJS)
	$(BCCDIR)\bin\tlib ..\lib\wattcpbs.lib /C /E @&&|
	  -+$(OBJS:.obj=-+)
|
	- @del ..\lib\wattcpbs.bak

..\lib\wattcpbl.lib: $(OBJS)
	$(BCCDIR)\bin\tlib ..\lib\wattcpbl.lib /C /E /P32 @&&|
	  -+$(OBJS:.obj=-+)
|
	- @del ..\lib\wattcpbl.bak

..\lib\wattcpbf.lib: $(OBJS)
	$(BCCDIR)\bin\tlib ..\lib\wattcpbf.lib /C /E /P32 @&&|
	  -+$(OBJS:.obj=-+)
|
	- @del ..\lib\wattcpbf.bak

..\lib\wattcpbw.lib: $(OBJS)
	$(BCCDIR)\bin\tlib ..\lib\wattcpbw.lib /C /E /P64 @&&|
	  -+$(OBJS:.obj=-+)
|
	- @del ..\lib\wattcpbw.bak

..\lib\wattcpbw_imp.lib: ..\bin\watt-32.dll

..\bin\watt-32.dll: $(OBJS) $(OBJDIR)\watt-32.res $(OBJDIR)\objects.arg
	- @del ..\bin\watt-32.dll
	- @del ..\lib\wattcpbw_imp.lib
	$(CC) $(LDFLAGS) -e..\bin\watt-32.dll @$(OBJDIR)\objects.arg
	$(BCCDIR)\bin\implib ..\lib\wattcpbw_imp.lib ..\bin\watt-32.dll
	- @del ..\bin\watt-32.tds
	@echo

clean:
	- @del $(OBJDIR)\*.obj
	- @del $(OBJDIR)\*.asm
	- @del $(OBJDIR)\*.res
	- @del $(OBJDIR)\*.arg
	- @del *.lst
	- @del $(TARGETS)
	- @del $(TEMP)\bcc_?.pch
	- @del pkt_stub.h
	@echo Cleaning done

$(OBJDIR)\objects.arg: $(MAKEFIL)
	@copy &&|
	 $(OBJS) $(OBJDIR)\watt-32.res
| $(OBJDIR)\objects.arg

$(C_ARGS): $(MAKEFIL)
	@copy &&|
	  $(CFLAGS)
| $<

$(OBJDIR)\asmpkt.obj:   asmpkt.asm
$(OBJDIR)\chksum0.obj:  chksum0.asm
$(OBJDIR)\cpumodel.obj: cpumodel.asm

.c.obj:
	$(CC) -q @$(C_ARGS) $*.c

.c.i:
	$(CPP) -q @$(C_ARGS) $*.c

.asm.obj:
	$(AS) $(AFLAGS) $*.asm, $(OBJDIR)\$*.obj

!include "build\borland\watt32.dep"

########################################################################

@elifdef WATCOM

.EXTENSIONS: .l

@ifdef SMALL
CC      = *wcc
CFLAGS  = -ms -0 -os -zc -s -zlf -bt=dos
AFLAGS  = -bt=dos
TARGET  = ..\lib\wattcpws.lib
OBJDIR  = build\watcom\small
MAKEFIL = watcom_s.mak

@elifdef LARGE
CC      = *wcc
CFLAGS  = -ml -0 -os -zc -s -zlf -bt=dos
AFLAGS  = -bt=dos
TARGET  = ..\lib\wattcpwl.lib
OBJDIR  = build\watcom\large
MAKEFIL = watcom_l.mak

@elifdef FLAT
CC      = *wcc386
CFLAGS  = -mf -3r -zff -zgf -zm -s -zlf -bt=dos -oilrtfm # -I$(%PHARLAP)\include
AFLAGS  = -bt=dos -3r -dDOSX -dDOS4GW
TARGET  = ..\lib\wattcpwf.lib
OBJDIR  = build\watcom\flat
MAKEFIL = watcom_f.mak

@elifdef WIN32
CC       = *wcc386
CFLAGS   = -mf -3r -zm -bd -bm -d3 -zlf -bt=nt -fp6 -oilrtfm -zri
AFLAGS   = -bt=nt -3s -dDOSX
LDFLAGS  = system nt dll
TARGET   = ..\lib\wattcpww.lib ..\lib\wattcpww_imp.lib
WATTDLL  = ..\bin\watt-32.dll
OBJDIR   = build\watcom\win32
MAKEFIL  = watcom_w.mak
RESOURCE = $(OBJDIR)\watt-32.res

@elifdef SMALL32
CC      = *wcc386
CFLAGS  = -ms -oaxt -s -zlf -bt=dos
AFLAGS  = -3 -bt=dos -dDOSX
TARGET  = ..\lib\wattcpw3.lib
OBJDIR  = build\watcom\small32
MAKEFIL = watcom_3.mak

@else
!error Unknown WATCOM model
@endif

LIBARG  = $(OBJDIR)\wlib.arg
LINKARG = $(OBJDIR)\wlink.arg
C_ARGS  = $(OBJDIR)\wcc.arg

AFLAGS += -zq -fr=nul -w3 -d1
CFLAGS += -zq -fr=nul -wx -fpi

#
# Since Watcom's internal (?) 'echo' sometimes fails to handle so many arguments in
# the 'cflags.h' rule below.
#
EXTRA_CFLAGS = -DWATT32_BUILD -I. -I..\inc -I$(%WATCOM)\h

#
# WCC386-flags used:
#   -m{s,l,f} memory model; small, large or flat
#   -3s       optimise for 386, stack call convention
#   -3r       optimise for 386, register calls
#   -s        no stack checking
#   -zq       quiet compiling
#   -d3       generate full debug info
#   -fpi      inline math + emulation
#   -fr       write errors to file (and stdout)
#   -bt=dos   target system - DOS
#   -bt=nt    target system - Win-NT
#   -zlf      always generate default library information
#   -zm       place each function in separate segment
#   -oilrtfm  optimization flags
#     i:      expand intrinsics
#     l:      loop optimisations
#     r:      reorder instructions
#     t:      favor execution time
#     f:      always use stack frames
#     m:      generate inline code for math functions
#
#  This should make the smallest code on a 386
#    -oahkrs -s -em -zp1 -3r -fp3
#
#  WCC-flags for small/large model:
#    -zc      place const data into the code segment
#    -os      optimization flags
#      s:     favour code size over execution time
#

AS = *wasm
AR = *wlib -q -b -c

all: $(PKT_STUB) $(C_ARGS) $(OBJDIR)\cflags.h $(OBJDIR)\cflagsbf.h $(TARGET)

@ifdef WIN32
$(WATTDLL) ..\lib\wattcpww_imp.lib: $(OBJS) $(RESOURCE) $(LINKARG)
	*wlink $(LDFLAGS) name $(WATTDLL) @$(LINKARG)
@endif

..\lib\wattcpww.lib: $(OBJS) $(LIBARG)
	$(AR) -p=1024 $^@ @$(LIBARG)

..\lib\wattcpws.lib: $(OBJS) $(LIBARG)
	$(AR) $^@ @$(LIBARG)

..\lib\wattcpwl.lib: $(OBJS) $(LIBARG)
	$(AR) $^@ @$(LIBARG)

..\lib\wattcpwf.lib: $(OBJS) $(LIBARG)
	$(AR) $^@ @$(LIBARG)

..\lib\wattcpw3.lib: $(OBJS) $(LIBARG)
	$(AR) $^@ @$(LIBARG)

-!include "build\watcom\watt32.dep"

$(OBJDIR)\asmpkt.obj:   asmpkt.asm
$(OBJDIR)\chksum0.obj:  chksum0.asm
$(OBJDIR)\cpumodel.obj: cpumodel.asm

.ERASE
.c{$(OBJDIR)}.obj:
	$(CC) $[@ @$(C_ARGS) -fo=$@

.ERASE
.asm{$(OBJDIR)}.obj:
	$(AS) $[@ $(AFLAGS) -fo=$@

$(C_ARGS): $(MAKEFIL)
	%create $^@
	%append $^@ $(CFLAGS) $(EXTRA_CFLAGS)

clean: .SYMBOLIC
	- @del $(OBJDIR)\*.obj
	- @del $(OBJDIR)\cflags.h
	- @del $(OBJDIR)\cflagsbf.h
	- @del $(TARGET)
	- @del $(C_ARGS)
	- @del $(LIBARG)
@ifdef WIN32
	- @del $(LINKARG)
	- @del $(WATTDLL)
	- @del $(RESOURCE)
	- @del ..\bin\watt-32.map
@else
	- @del pkt_stub.h
@endif
	@echo Cleaning done

$(LIBARG): $(MAKEFIL)
	%create $^@
	@for %f in ($(OBJS)) do @%append $^@ +- %f

@ifdef WIN32
$(LINKARG): $(__MAKEFILES__)
	%create $^@
	@%append $^@ option implib=..\lib\wattcpww_imp.lib, quiet, map, verbose,
	@%append $^@ caseexact, map=..\bin\watt-32.map, res=$(RESOURCE)
	@%append $^@ file { $(OBJS) }
@endif

########################################################################

@elifdef VISUALC

#
# A perculiar feature (or bug?) with the MS linker is that the import
# libs (..\lib\$(CPU)\wattcpvc_imp.lib + ..\lib\$(CPU)\wattcpvc_imp_d.lib) can get
# older than the target .dll they represent. Hence the below 'touch'
# commands.
#
# Special <crtdefs.h> defines:
#  _CRT_SECURE_NO_WARNINGS
#  _CRT_SECURE_NO_DEPRECATE
#  _CRT_SECURE_NO_WARNINGS_GLOBALS
#  _CRT_NONSTDC_NO_WARNINGS
#  _CRT_OBSOLETE_NO_WARNINGS
#
# Note: 'cdecl' (-Gd) is default. Check if '__fastcall' (-Gr) in '_DEBUG' mode
#       is possible.
#
# The Microsoft Macro Assembler (ml and ml64) is available here:
#   http://www.microsoft.com/en-us/download/details.aspx?id=12654
#
@ifndef WIN32 WIN64
!error The only possible targets for VISUALC are WIN32 or WIN64
@endif

CFLAGS = -nologo -Zi -W3 -DWATT32_BUILD -D_WIN32_WINNT=0x0601 -I. -I../inc

#
# Just a test
#
# CFLAGS = $(CFLAGS) -DWATT32_NO_NAMESPACE

#
# Do not use the so called "POSIX supplemented" error-codes.
# They are of little use since a 'strerror(x)' always returns
# "unknown error" for these.
#
# CFLAGS = $(CFLAGS) -D_CRT_NO_POSIX_ERROR_CODE

@ifdef DEBUG
CFLAGS = $(CFLAGS) -MDd -Ot -D_DEBUG -EHsc -RTCc -RTCs -RTCu -GF -GS # -Gr
@else
CFLAGS = $(CFLAGS) -MD -Ox -GS- # -Gr
@endif

@ifdef WIN64
BITS    = 64
LDFLAGS = -machine:x64
AS      = ml64
AFLAGS  = -c -nologo -DDOSX -DWIN64 -Zi -Fl

@ifdef DEBUG
TARGETS = ..\lib\x64\wattcpvc_d.lib ..\lib\x64\wattcpvc_imp_d.lib ..\bin\watt-32d_64.dll
OBJDIR  = build\visualc\64bit\debug

@else
TARGETS = ..\lib\x64\wattcpvc.lib ..\lib\x64\wattcpvc_imp.lib ..\bin\watt-32_64.dll
OBJDIR  = build\visualc\64bit\release
@endif

@else
#
# WIN32
#
BITS    = 32
LDFLAGS = -machine:x86
AS      = ml
AFLAGS  = -c -nologo -DDOSX -Zi -Fl -coff

@ifdef DEBUG
TARGETS = ..\lib\x86\wattcpvc_d.lib ..\lib\x86\wattcpvc_imp_d.lib ..\bin\watt-32d.dll
OBJDIR  = build\visualc\32bit\debug
MAKEFIL = visualc-debug_$(BITS).mak

@else
TARGETS = ..\lib\x86\wattcpvc.lib ..\lib\x86\wattcpvc_imp.lib ..\bin\watt-32.dll
OBJDIR  = build\visualc\32bit\release
MAKEFIL = visualc-release_$(BITS).mak
@endif

@endif

CC      = cl
LDFLAGS = -dll -nologo -map -debug -debugtype:cv -incremental:no -verbose $(LDFLAGS)

#
# The 'lib' command common to MSVC: Win32/Win64
#
AR = lib -nologo -ignore:4221

#
# Ignore warning:
#   xyz.obj : warning LNK4221: This object file does not define any previously undefined
#   public symbols, so it will not be used by any link operation that consumes this library
#
# May not be supported by all 'link' versions.
#
LDFLAGS = $(LDFLAGS) -ignore:4221

#
# Enable the watt-32.dll to be used on Win-XP SP3 (5.2) in case
# it was built under Win-Vista+
#
LDFLAGS  = $(LDFLAGS) -subsystem:console,5.02

EX_LIBS  = user32.lib advapi32.lib
RESOURCE = $(OBJDIR)\watt-32.res
C_ARGS   = $(OBJDIR)\cl.arg

all: $(C_ARGS) $(OBJDIR)\cflags.h $(OBJDIR)\cflagsbf.h $(TARGETS)
	@echo All done

$(C_ARGS): $(MAKEFIL)
	@echo $(CFLAGS) > $@

@ifdef DEBUG
#
# Static libs (debug)
#
..\lib\x86\wattcpvc_d.lib: $(OBJS)
	$(AR) -machine:x86 -out:$@ @<<
	 $**
<<

..\lib\x64\wattcpvc_d.lib: $(OBJS)
	$(AR) -machine:x64 -out:$@ @<<
	 $**
<<

#
# Import libs + DLLs (debug)
#
..\bin\watt-32d.dll ..\lib\x86\wattcpvc_imp_d.lib: $(OBJS) $(RESOURCE)
	link $(LDFLAGS) -out:..\bin\watt-32d.dll -implib:..\lib\x86\wattcpvc_imp_d.lib \
	     $** $(EX_LIBS) > link.tmp
	type link.tmp >> ..\bin\watt-32d.map
	touch ../lib/x86/wattcpvc_imp_d.lib

..\bin\watt-32d_64.dll ..\lib\x64\wattcpvc_imp_d.lib: $(OBJS) $(RESOURCE)
	link $(LDFLAGS) -out:..\bin\watt-32d_64.dll -implib:..\lib\x64\wattcpvc_imp_d.lib \
	     $** $(EX_LIBS) > link.tmp
	type link.tmp >> ..\bin\watt-32d_64.map
	touch ../lib/x64/wattcpvc_imp_d.lib
@else

#
# Static libs (release)
#
..\lib\x86\wattcpvc.lib: $(OBJS)
	$(AR) -machine:x86 -out:$@ @<<
	 $**
<<

..\lib\x64\wattcpvc.lib: $(OBJS)
	$(AR) -machine:x64 -out:$@ @<<
	 $**
<<

#
# Import libs + DLLs (release)
#
..\bin\watt-32.dll ..\lib\x86\wattcpvc_imp.lib: $(OBJS) $(RESOURCE)
	link $(LDFLAGS) -out:..\bin\watt-32.dll -implib:..\lib\x86\wattcpvc_imp.lib \
	     $** $(EX_LIBS) > link.tmp
	type link.tmp >> ..\bin\watt-32.map
	touch ../lib/x86/wattcpvc_imp.lib

..\bin\watt-32_64.dll ..\lib\x64\wattcpvc_imp.lib: $(OBJS) $(RESOURCE)
	link $(LDFLAGS) -out:..\bin\watt-32_64.dll -implib:..\lib\x64\wattcpvc_imp.lib \
	     $** $(EX_LIBS) > link.tmp
	type link.tmp >> ..\bin\watt-32_64.map
	touch ../lib/x64/wattcpvc_imp.lib
@endif

clean:
	- @del $(TARGETS)
	- @del $(C_ARGS)
	- @del $(OBJDIR)\*.obj
	- @del $(RESOURCE)
	- @del *.lst
	- @del vc1*.pdb
	- @del ..\lib\x86\wattcpcvc_*.exp
	- @del ..\lib\x64\wattcpcvc_*.exp
	- @del ..\bin\watt-32?$(64).pdb
	@echo Cleaning done

$(OBJDIR)\chksum0.obj:  chksum0.asm
$(OBJDIR)\cpumodel.obj: cpumodel.asm

.cpp{$(OBJDIR)}.obj:
	$(CC) -c @$(C_ARGS) -EHsc -Fo.\$*.obj $<

.c{$(OBJDIR)}.obj:
	$(CC) -c @$(C_ARGS) -Fo.\$*.obj $<

.asm{$(OBJDIR)}.obj:
	$(AS) $(AFLAGS) -Fo.\$*.obj $<

!include build\visualc\watt32.dep

########################################################################

@elifdef LCC

@ifndef WIN32
!error The only possible target for LCC is WIN32
@endif

CC      = lcc
CFLAGS  = -g2 -O -A -I. -I../inc -DWATT32_BUILD
OBJDIR  = build\lcc
TARGETS = ..\lib\wattcp_lcc.lib ..\lib\wattcp_lcc_imp.lib ..\bin\watt-32.dll
MAKEFIL = lcc.mak

AS       = tasm32
AFLAGS   = -DDOSX -mx -m2 -t -l
LDFLAGS  = -subsystem console -dll -dynamic
EX_LIBS  = user32.lib advapi32.lib
RESOURCE = $(OBJDIR)\watt-32.res

all: $(OBJDIR)\cflagsbf.h $(TARGETS)
	@echo All done

..\lib\wattcp_lcc.lib: $(OBJS)
	@echo Generating ..\lib\wattcp_lcc.lib ...
	@cd $(OBJDIR)
	@for %f in (*.obj) do lcclib ..\..\lib\wattcp_lcc.lib %f
	@cd ..

#
# Import lib + DLL (debug)
#
..\bin\watt-32.dll ..\lib\wattcp_lcc_imp.lib: $(OBJS)
	lcclnk $(LDFLAGS) -o ..\bin\watt-32.dll -map watt-32.map $(OBJS) $(EX_LIBS)
	implib ..\lib\wattcp_lcc_imp.lib ..\bin\watt-32.dll

clean:
	- @del $(TARGETS)
	- @del $(OBJDIR)\*.obj
	- @del $(OBJDIR)\cflagsbf.h
	- @del $(RESOURCE)
	- @del *.lst
	@echo Cleaning done

$(OBJDIR)\chksum0.obj:  chksum0.asm
$(OBJDIR)\cpumodel.obj: cpumodel.asm

.c{$(OBJDIR)}.obj:
	$(CC) -c $(CFLAGS) -o $*.obj $<

.asm{$(OBJDIR)}.obj:
	$(AS) $(AFLAGS) $<, $*.obj

!include $(OBJDIR)\watt32.dep

########################################################################

@elifdef CLANG

CC     = clang-cl
CFLAGS = -nologo -Zi -Zo -GS- -I. -I../inc \
         -DWATT32_BUILD                    \
         -D_CRT_SECURE_NO_WARNINGS         \
         -D_CRT_NONSTDC_NO_WARNINGS        \
         -D_CRT_OBSOLETE_NO_WARNINGS       \
         -D_WIN32_WINNT=0x0601             \
         -D_WINSOCK_DEPRECATED_NO_WARNINGS \
         -DBUILD_WINDOWS

CFLAGS += -Wno-\#pragma-messages

#
# This is handy warning:
#
CFLAGS += -Wmissing-prototypes

@ifdef DEBUG
  CFLAGS += -MDd
@else
  CFLAGS += -MD -Ox
@endif

#
# Enable full Microsoft Visual C++ compatibility
#
CFLAGS += -fms-compatibility
LDFLAGS = -dll -nologo -map -debug -debugtype:cv -incremental:no -verbose

#
# The 'lib' command common to Win32/Win64
#
AR = lib -nologo

#
# Ignore warning:
#   xyz.obj : warning LNK4221: This object file does not define any previously undefined
#   public symbols, so it will not be used by any link operation that consumes this library
#
# May not be supported by all 'lib' and 'link' versions.
#
LDFLAGS += -ignore:4221
AR      += -ignore:4221

#
# Enable the watt-32.dll to be used on Win-XP SP3 (5.2) in case
# it was built under Win-Vista+
#
LDFLAGS += -subsystem:console,5.02

EX_LIBS  = user32.lib advapi32.lib
RESOURCE = $(OBJDIR)/watt-32.res

@ifdef WIN64
  64     = _64
  AS     = ml64
  AFLAGS = -c -nologo -DDOSX -DWIN64 -Zi -Fl

  @ifdef DEBUG
  TARGETS = ../lib/x64/wattcp_clang.lib ../lib/x64/wattcp_clang_imp.lib ../bin/watt-32_64.dll
  OBJDIR  = build/clang/64bit/debug
  @else
  TARGETS = ../lib/x64/wattcp_clang.lib ../lib/x64/wattcp_clang_imp.lib ../bin/watt-32_64.dll
  OBJDIR  = build/clang/64bit/release
  @endif
@else
  64     =
  AS     = ml
  AFLAGS = -c -nologo -DDOSX -Zi -Fl -coff

  @ifdef DEBUG
  TARGETS = ../lib/x86/wattcp_clang_d.lib ../lib/x86/wattcp_clang_imp_d.lib ../bin/watt-32d.dll
  OBJDIR  = build/clang/32bit/debug
  @else
  TARGETS = ../lib/x86/wattcp_clang.lib ../lib/x86/wattcp_clang_imp.lib ../bin/watt-32.dll
  OBJDIR  = build/clang/32bit/release
  @endif
@endif

C_ARGS = $(OBJDIR)/clang.arg

OBJS := $(subst \,/,$(OBJS))

#
# In case '%CL%' is set, it may confuse 'clang-cl'. Unset it.
#
export CL=

all: $(C_ARGS) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h $(TARGETS)
	@echo All done

#
# Static library rules:
#
../lib/x86/wattcp_clang.lib: $(OBJS)
	$(AR) -machine:x86 -out:$@ $(OBJS)

../lib/x86/wattcp_clang_d.lib: $(OBJS)
	$(AR) -machine:x86 -out:$@ $(OBJS)

../lib/x64/wattcp_clang.lib: $(OBJS)
	$(AR) -machine:x64 -out:$@ $(OBJS)

../lib/x64/wattcp_clang_d.lib: $(OBJS)
	$(AR) -machine:x64 -out:$@ $(OBJS)

$(C_ARGS): $(MAKEFILE_LIST)
	@echo $(CFLAGS) > $@

#
# Import lib + DLL (release)
#
../lib/x86/wattcp_clang_imp.lib: ../bin/watt-32.dll
../lib/x64/wattcp_clang_imp.lib: ../bin/watt-32_64.dll

../bin/watt-32.dll: $(OBJS) $(RESOURCE)
	link $(LDFLAGS) -machine:x86 -out:$@ -implib:../lib/x86/wattcp_clang_imp.lib $^ $(EX_LIBS) > link.tmp
	cat link.tmp >> ../bin/watt-32.map
	rm -f ../lib/x86/wattcp_clang_imp.exp

../bin/watt-32_64.dll: $(OBJS) $(RESOURCE)
	link $(LDFLAGS) -machine:x64 -out:$@ -implib:../lib/x64/wattcp_clang_imp.lib $^ $(EX_LIBS) > link.tmp
	cat link.tmp >> ../bin/watt-32_64.map
	rm -f ../lib/x64/wattcp_clang_imp.exp

#
# Import lib + DLL (debug)
#
../lib/x86/wattcp_clang_imp_d.lib: ../bin/watt-32d.dll
../lib/x64/wattcp_clang_imp_d.lib: ../bin/watt-32_64d.dll

../bin/watt-32d.dll: $(OBJS) $(RESOURCE)
	link $(LDFLAGS) -machine:x86 -out:$@ -implib:../lib/x86/wattcp_clang_imp_d.lib $^ $(EX_LIBS) > link.tmp
	cat link.tmp >> ../bin/watt-32d.map
	rm -f ../lib/x86/wattcp_clang_imp_d.exp

../bin/watt-32_64d.dll: $(OBJS) $(RESOURCE)
	link $(LDFLAGS) -machine:x64 -out:$@ -implib:../lib/x64/wattcp_clang_imp_d.lib $^ $(EX_LIBS) > link.tmp
	cat link.tmp >> ../bin/watt-32_64d.map
	rm -f ../lib/x64/wattcp_clang_imp_d.exp

clean:
	- rm -f $(TARGETS) $(C_ARGS) $(OBJDIR)/*.obj $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h $(RESOURCE) chksum0.lst cpumodel.lst
	@echo Cleaning done

$(OBJDIR)/%.obj: %.c
	$(CC) -c @$(C_ARGS) -Fo.\$@ $<

$(OBJDIR)/%.obj: %.cpp
	$(CC) -c -TP -EHsc @$(C_ARGS) -Fo.\$@ $<

$(OBJDIR)/%.obj: %.asm
	$(AS) $(AFLAGS) -Fo.\$@ $<

include build/clang/watt32.dep

########################################################################

@elifdef HIGHC

OBJDIR  = build/highc
TARGET  = ../lib/wattcphf.lib
MAKEFIL = highc.mak

CC     = hc386
C_ARGS = $(OBJDIR)/highc.arg

CFLAGS = -I. -I../inc -I$(PHARLAP)/include -w3 -g -O2 -DWATT32_BUILD \
         -Hpentium_only -DBUGGY_FARPTR=1 -Hnocopyr -Hnoswap          \
         -Hon=relax_func_ptr_rules -Hon=Preload_args_from_memory     \
         -Hon=char_is_rep -Hon=quiet -Hoff=check_stack               \
         -Hon=Recognize_library -Hon=Align_labels -Hoff=Call_trace   \
         -Hpragma=stack_size_warn(10000) -Hoff=Prolog_trace          \
         -Hoff=Epilog_trace -Hpragma=Offwarn(257)                    \
         -Hpragma=Offwarn(572) -Hpragma=Offwarn(578) -Hpragma=Offwarn(491)

AS     = tasm32
AFLAGS = -DDOSX -mx -m2 -t -l
AR     = 386lib -nobanner

OBJS := $(subst \,/,$(OBJS))

all: $(PKT_STUB) $(C_ARGS) $(OBJDIR)/cflagsbf.h $(TARGET)
	@echo All done

$(TARGET): $(OBJS)
	@echo -nowarn -nobackup -twocase -pagesize 32 > $(OBJDIR)/lib.arg
	@echo -replace $(OBJS)                       >> $(OBJDIR)/lib.arg
	$(AR) $(TARGET) @$(OBJDIR)/lib.arg

clean:
	rm -f $(OBJDIR)/*.obj $(OBJDIR)/cflagsbf.h chksum0.lst cpumodel.lst $(TARGET) pkt_stub.h
	@echo Cleaning done

$(OBJDIR)/chksum0.obj: chksum0.asm
	$(AS) $(AFLAGS) $<, $(OBJDIR)\chksum0.obj

$(OBJDIR)/cpumodel.obj: cpumodel.asm
	$(AS) $(AFLAGS) $<, $(OBJDIR)\cpumodel.obj

$(C_ARGS): $(MAKEFIL)
	@echo '$(CFLAGS)' > $@

$(OBJDIR)/%.obj: %.c
	$(CC) -c @$(C_ARGS) -o $@ $<

include $(OBJDIR)/watt32.dep

########################################################################

@elifdef LADSOFT

CC      = cc386
CFLAGS  = -I. -I..\inc +v -O+a -O+i -C+N -DWATT32_BUILD
AR      = xlib
AS      = tasm32
AFLAGS  = -DDOSX -DDOS4GW -mx -m2 -t -l
OBJDIR  = build\ladsoft
MAKEFIL = ladsoft.mak
TARGET  = ..\lib\wattcplf.lib

.SWAP

all: $(PKT_STUB) $(OBJDIR)\cflagsbf.h $(TARGET)
	@echo All done

$(TARGET): $(OBJS)
	$(AR) $(TARGET) @$(OBJDIR)\xlib.rsp
	- @del $(TARGET:.lib=.bak)

clean:
	- @del $(OBJDIR)\*.obj
	- @del $(OBJDIR)\*.asm
	- @del $(OBJDIR)\*.lst
	- @del $(TARGET)
	- @del pkt_stub.h
	@echo Cleaning done

$(OBJDIR)\chksum0.obj:  chksum0.asm
$(OBJDIR)\cpumodel.obj: cpumodel.asm

.c.obj:
	$(CC) -c $(CFLAGS) $*.c -o$(OBJDIR)\$*.asm
	$(W32_NASM) -s -f obj -l $(OBJDIR)\$*.lst -o $(OBJDIR)\$*.obj $(OBJDIR)\$*.asm

.asm.obj:
	$(AS) $(AFLAGS) $*.asm, $(OBJDIR)\$*.obj

!include "build\ladsoft\watt32.dep"

########################################################################

@elifdef MINGW32

CC      = gcc
CFLAGS  = -O2 -g -Wall -Wno-strict-aliasing -mthreads -pipe -I. -I../inc \
          -DWATT32_BUILD -D_WIN32_WINNT=0x0601 -DWINVER=0x0601

LDFLAGS = -shared -Wl,--enable-stdcall-fixup,--print-map,--sort-common,--cref

#
# Generate PCH
#
# $(CC) -x c-header -c $(CFLAGS) -o $(OBDIR)/pch.gch/c socket.h
#
# CFLAGS += -mavx -mfma
#
# gcc/as debug formats:
#
CFLAGS += -gstabs
AFLAGS += -gstabs

#
# In the case where 'MinGW32.mak' file is erroneously used to
# build a 64-bit Watt-32 DLL (using e.g. TDM-gcc's "dual-mode" gcc).
# Since in MinGW-w64, 'gcc' w/o '-m32', will generate 64-bit code,
# the result from this makefile is '../bin/watt-32.dll'. And not
# '../bin/watt-32_64.dll'. To build for MinGW-w64 or TDM-gcc, use
# one of these commands:
#   make -f MinGW64_32.mak
#   make -f MinGW64_64.mak
#
# If your gcc/ld/as bundled with the old-school MinGW is too old,
# comment away the '-m32' + '--32' below.
#
CFLAGS  += -m32
LDFLAGS += -m32
AFLAGS  += --32

#
# Just a test
#
CFLAGS += -std=c99

AS       = as
AR       = ar rs
TARGETS  = ../lib/libwatt32.a ../lib/libwatt32.dll.a ../bin/watt-32.dll
OBJDIR   = build/MinGW32
RESOURCE = $(OBJDIR)/watt-32.res

OBJS := $(subst \,/,$(OBJS))
OBJS := $(subst .obj,.o,$(OBJS))

ifeq ($(USE_MPATROL),1)
  EX_LIBS = -lmpatrol -lbfd -liberty -lintl -limagehlp
endif

all: $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h $(TARGETS)
	@echo All done

../lib/libwatt32.a: $(OBJS)
	$(AR) $@ $?

../lib/libwatt32.dll.a ../bin/watt-32.dll: $(OBJS) $(RESOURCE)
	$(CC) $(LDFLAGS) -Wl,--out-implib,../lib/libwatt32.dll.a \
          -o ../bin/watt-32.dll $^ $(EX_LIBS) > ../bin/watt-32.map

$(OBJDIR)/chksum0.o:  chksum0.S
$(OBJDIR)/cpumodel.o: cpumodel.S

$(OBJDIR)/%.o: %.c
	$(CC) $(CFLAGS) -o $@ -c $<

$(OBJDIR)/%.o: %.S
	$(CC) -E $(CFLAGS) $< > $(OBJDIR)/$*.iS
	$(AS) $(AFLAGS) $(OBJDIR)/$*.iS -o $@

clean:
	rm -f $(TARGETS) $(OBJDIR)/*.o $(OBJDIR)/*.iS $(RESOURCE) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h
	@echo Cleaning done

-include $(OBJDIR)/watt32.dep

########################################################################

@elifdef MINGW64

NO_OPT ?= 0
CC      = gcc

ifeq ($(NO_OPT),0)
  CFLAGS = -O2 -g -gstabs
else
  #
  # 'make NO_OPT=1 -f *.mak' -> tests gcc 5.x with no optimisations
  #                             and old-style inlining.
  #
  CFLAGS = -O0 -g2 -fgnu89-inline
endif

CFLAGS += -Wall -Wundef -Wno-strict-aliasing -I. -I../inc \
          -DWATT32_BUILD -D_WIN32_WINNT=0x0601 -DWINVER=0x0601
LDFLAGS = -shared -Wl,--enable-stdcall-fixup,--print-map,--sort-common,--cref

#
# configur.bat + mkmake.exe generates 2 makefiles for MINGW64:
#  * for 32-bit programs, use MinGW64_32.mak.
#  * for 64-bit programs, use MinGW64_64.mak.
#
# I have tested TDM-gcc [1] only. [2] may work here too. (And
# there are other MinGW64 packages too).
# For TDM-gcc, 64-bit programs is the default (unless '-m32' is used).
#
# [1] http://tdm-gcc.tdragon.net/
# [2] http://mingw-w64.sourceforge.net/
#
# And the 'PATH' must have been setup to choose the correct 'gcc.exe'.
#
@ifdef WIN64
  BITS    = 64
  TARGETS = ../lib/x64/libwatt32.a ../lib/x64/libwatt32.dll.a ../bin/watt-32_64.dll
@else
  BITS    = 32
  TARGETS = ../lib/x86/libwatt32.a ../lib/x86/libwatt32.dll.a ../bin/watt-32.dll
@endif

OBJDIR   = build/MinGW64/$(BITS)bit
CFLAGS  += -m$(BITS)
LDFLAGS += -m$(BITS)
AFLAGS  += --$(BITS) -gstabs

AS       = as
AR       = ar rs
RESOURCE = $(OBJDIR)/watt-32.res
EX_LIBS  =

OBJS := $(subst \,/,$(OBJS))
OBJS := $(subst .obj,.o,$(OBJS))

#
# Since these were excluded above
#
# OBJS := $(OBJDIR)/cpumodel.o $(OBJDIR)/chksum0.o $(OBJS)

all: $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h $(TARGETS)
	@echo All done

../lib/x86/libwatt32.a: $(OBJS)
	$(AR) $@ $?

../lib/x64/libwatt32.a: $(OBJS)
	$(AR) $@ $?

../lib/x86/libwatt32.dll.a ../bin/watt-32.dll: $(OBJS) $(RESOURCE)
	$(CC) $(LDFLAGS) -Wl,--out-implib,../lib/x86/libwatt32.dll.a \
          -o ../bin/watt-32.dll $^ $(EX_LIBS) > ../bin/watt-32.map

../lib/x64/libwatt32.dll.a ../bin/watt-32_64.dll: $(OBJS) $(RESOURCE)
	$(CC) $(LDFLAGS) -Wl,--out-implib,../lib/x64/libwatt32.dll.a \
          -o ../bin/watt-32_64.dll $^ $(EX_LIBS) > ../bin/watt-32_64.map

$(OBJDIR)/chksum0.o:  chksum0.S
$(OBJDIR)/cpumodel.o: cpumodel.S

$(OBJDIR)/%.o: %.c
	$(CC) $(CFLAGS) -o $@ -c $<

$(OBJDIR)/%.o: %.S
	$(CC) -E $(CFLAGS) $< > $(OBJDIR)/$*.iS
	$(AS) $(AFLAGS) $(OBJDIR)/$*.iS -o $@

clean:
	rm -f $(TARGETS) $(OBJDIR)/*.o $(OBJDIR)/*.iS $(RESOURCE) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h
	@echo Cleaning done

-include $(OBJDIR)/watt32.dep

########################################################################

@elifdef CYGWIN32

CC       = gcc
CFLAGS   = -O2 -g -Wall -mthreads -fno-strict-aliasing -static-libgcc -I. -I../inc -DWATT32_BUILD
LDFLAGS  = -shared -static-libgcc
AS       = as
AR       = ar rs
TARGETS  = ../lib/x86/libwatt32-cygwin.a ../lib/x86/libwatt32-cygwin.dll.a ../bin/watt-32.dll
OBJDIR   = ./build/CygWin/32bit
RESOURCE = $(OBJDIR)/watt-32.res

#
# This seems to require NewLib which I've not tested.
# CFLAGS += -D_REENT_ONLY
#
OBJS := $(subst \,/,$(OBJS))
OBJS := $(subst .obj,.o,$(OBJS))

all: $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h $(TARGETS)
	@echo All done

../lib/x86/libwatt32-cygwin.a: $(OBJS)
	$(AR) $@ $?

../lib/x86/libwatt32-cygwin.dll.a: ../bin/watt-32.dll

../bin/watt-32.dll: $(OBJS) $(RESOURCE)
	$(CC) $(LDFLAGS) -Wl,--enable-stdcall-fixup,--out-implib,../lib/x86/libwatt32-cygwin.dll.a \
          -o ../bin/watt-32.dll $^

$(OBJDIR)/chksum0.o:  chksum0.S
$(OBJDIR)/cpumodel.o: cpumodel.S

$(OBJDIR)/%.o: %.c
	$(CC) $(CFLAGS) -o $@ -c $<

$(OBJDIR)/%.o: %.S
	$(CC) -E $(CFLAGS) $< > $(OBJDIR)/$*.iS
	$(AS) $(AFLAGS) $(OBJDIR)/$*.iS -o $@

clean:
	rm -f $(TARGETS) $(OBJDIR)/*.o $(OBJDIR)/*.iS $(RESOURCE) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h
	@echo Cleaning done

-include $(OBJDIR)/watt32.dep

########################################################################

@elifdef CYGWIN64

CC       = gcc
CFLAGS   = -m64 -O2 -g -Wall -mthreads -fno-strict-aliasing -static-libgcc -I. -I../inc \
           -DWATT32_BUILD
LDFLAGS += -m64 -shared -static-libgcc
AS       = as
AFLAGS   = --64 -ahls
AR       = ar rs

TARGETS  = ../lib/x64/libwatt32-cygwin.a ../lib/x64/libwatt32-cygwin.dll.a ../bin/watt-32_64.dll
OBJDIR   = ./build/CygWin/64bit
RESOURCE = $(OBJDIR)/watt-32.res

OBJS := $(subst \,/,$(OBJS))
OBJS := $(subst .obj,.o,$(OBJS))

all: $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h $(TARGETS)
	@echo All done

../lib/x64/libwatt32-cygwin.a: $(OBJS)
	$(AR) $@ $?

../lib/x64/libwatt32-cygwin.dll.a: ../bin/watt-32_64.dll

../bin/watt-32_64.dll: $(OBJS) $(RESOURCE)
	$(CC) $(LDFLAGS) -Wl,--out-implib,../lib/x64/libwatt32-cygwin.dll.a \
          -o ../bin/watt-32_64.dll $^

$(OBJDIR)/chksum0.o:  chksum0.S
$(OBJDIR)/cpumodel.o: cpumodel.S

$(OBJDIR)/%.o: %.c
	$(CC) $(CFLAGS) -o $@ -c $<

$(OBJDIR)/%.i: %.c
	$(CC) -E $(CFLAGS) -o $@ -c $<

$(OBJDIR)/%.o: %.S
	$(CC) -E $(CFLAGS) $< > $(OBJDIR)/$*.iS
	$(AS) $(AFLAGS) $(OBJDIR)/$*.iS -o $@ > $*.lst

clean:
	rm -f $(TARGETS) $(OBJDIR)/*.o $(OBJDIR)/*.iS $(RESOURCE) $(OBJDIR)/cflags.h $(OBJDIR)/cflagsbf.h
	@echo Cleaning done

-include $(OBJDIR)/watt32.dep

########################################################################

@elifdef PELLESC

@ifndef WIN32 WIN64
!error The only possible target for PELLESC is WIN32 or WIN64
@endif

@ifdef WIN64
CFLAGS  = -Tx64-coff -DWIN32
LDFLAGS = -machine:x64
AS      = ml64
AFLAGS  = -DDOSX -DWIN64 -Fl
TARGETS = ..\lib\x64\wattcppo.lib ..\lib\x64\wattcppo_imp.lib ..\bin\watt-32_64.dll
WINLIB  = $(PELLESC)\lib\Win64
OBJDIR  = build\pellesc\64bit
MAKEFIL = pellesc_64.mak

@else
CFLAGS  = -Tx86-coff
LDFLAGS = -machine:x86
AS      = ml
AFLAGS  = -DDOSX -DWIN32 -Fl -coff
TARGETS = ..\lib\x86\wattcppo.lib ..\lib\x86\wattcppo_imp.lib ..\bin\watt-32.dll
WINLIB  = $(PELLESC)\lib\Win
OBJDIR  = build\pellesc\32bit
MAKEFIL = pellesc.mak
@endif

CC      = pocc
CFLAGS  = $(CFLAGS) -DWATT32_BUILD -MT -X -Ox -Ob1 -Ze -Zi -W1 -Go \
          -I$(PELLESC)\include -I$(PELLESC)\include\win -I. -I..\inc # -std:C99

AFLAGS  = -c -nologo -Zi $(AFLAGS)

# AS      = poasm
# AFLAGS  = -DDOSX -Zd -Fl

RESOURCE = $(OBJDIR)\watt-32.res

LDFLAGS =  $(LDFLAGS) -dll -map -libpath:$(PELLESC)\lib -libpath:$(WINLIB) \
          -subsystem:console -debug -verbose

EX_LIBS = user32.lib kernel32.lib advapi32.lib

all: $(OBJDIR)\cflagsbf.h $(TARGETS)
	@echo All done

..\lib\x86\wattcppo.lib: $(OBJS)
	polib -out:$@ $**

..\lib\x64\wattcppo.lib: $(OBJS)
	polib -out:$@ $**

..\bin\watt-32.dll ..\lib\x86\wattcppo_imp.lib: $(OBJS) $(RESOURCE)
	polink $(LDFLAGS) -out:..\bin\watt-32.dll -implib:..\lib\x86\wattcppo_imp.lib \
           $** $(EX_LIBS) > link.tmp
	type link.tmp >> ..\bin\watt-32.map

..\bin\watt-32_64.dll ..\lib\x64\wattcppo_imp.lib: $(OBJS) $(RESOURCE)
	polink $(LDFLAGS) -out:..\bin\watt-32_64.dll -implib:..\lib\x64\wattcppo_imp.lib \
           $** $(EX_LIBS) > link.tmp
	type link.tmp >> ..\bin\watt-32_64.map

clean:
	- @del $(TARGETS)
	- @del $(RESOURCE)
	- @del $(OBJDIR)\*.obj
	- @del $(OBJDIR)\cflagsbf.h
	- @del *.lst
	@echo Cleaning done

$(OBJDIR)\chksum0.obj:  chksum0.asm
$(OBJDIR)\cpumodel.obj: cpumodel.asm

.c{$(OBJDIR)}.obj:
	$(CC) -c $(CFLAGS) -Fo$*.obj $<

.asm{$(OBJDIR)}.obj:
	$(AS) $(AFLAGS) -Fo $*.obj $<

!include build\pellesc\watt32.dep

@endif

########################################################################

doxygen:
	doxygen doxyfile

lang.c: lang.l
	flex -8 -t lang.l > lang.c

@ifdef DJGPP MINGW32 MINGW64 CLANG CYGWIN32 CYGWIN64 CLANG HIGHC
#
# GNU-Make rules uses shell 'sh' commands:
#
$(OBJDIR)/cflags.h: $(MAKEFILE_LIST)
	echo 'const char *w32_cflags = "$(CFLAGS)";' > $(OBJDIR)/cflags.h
	echo 'const char *w32_cc     = "$(CC)";'    >> $(OBJDIR)/cflags.h

@elifdef BORLAND
$(OBJDIR)\cflags.h: $(MAKEFIL)
	echo const char *w32_cflags = '"$(CFLAGS)";' > $(OBJDIR)\cflags.h
	echo const char *w32_cc     = '"$(CC)";'    >> $(OBJDIR)\cflags.h

@else
#
# This is for Watcom etc. which could possibly not handle all the arguments in
# the 'CFLAGS'. We to do this in several steps creating a multiline string
# for 'w32_cflags'!
#
$(OBJDIR)\cflags.h: $(MAKEFIL)
	echo const char *w32_cflags =       > $(OBJDIR)\cflags.h
	echo            "$(CFLAGS)"        >> $(OBJDIR)\cflags.h
	echo            "$(EXTRA_CFLAGS);" >> $(OBJDIR)\cflags.h
	echo const char *w32_cc = "$(CC)"; >> $(OBJDIR)\cflags.h
@endif

@ifdef DJGPP

$(OBJDIR)/pcpkt.o: asmpkt.nas

$(PKT_STUB): asmpkt.nas
	$(W32_NASM_) -f bin -l asmpkt.lst -o asmpkt.bin asmpkt.nas
	$(W32_BIN2C_) asmpkt.bin > $@

@elifdef HIGHC

$(OBJDIR)/pcpkt.obj: asmpkt.nas

$(PKT_STUB): asmpkt.nas
	$(W32_NASM) -f bin -l asmpkt.lst -o asmpkt.bin asmpkt.nas
	$(W32_BIN2C) asmpkt.bin > $@

@elifdef FLAT SMALL32

$(OBJDIR)\pcpkt.obj: asmpkt.nas

@ifdef WATCOM
$(PKT_STUB): asmpkt.nas
	$(%W32_NASM) -f bin -l asmpkt.lst -o asmpkt.bin asmpkt.nas
	$(%W32_BIN2C) asmpkt.bin > $@

@else

$(PKT_STUB): asmpkt.nas
	$(W32_NASM) -f bin -l asmpkt.lst -o asmpkt.bin asmpkt.nas
	$(W32_BIN2C) asmpkt.bin > $@
@endif

@endif  # FLAT

@ifdef MINGW32 MINGW64 CLANG CYGWIN32 CYGWIN64
  #
  # All these Windows targets uses GNU-make. Hence it should be safe to
  # assume the 'date' program is available.
  #
  DATE = $(shell date +%d-%B-%Y)
@endif

build\Borland\Win32\watt-32.res: watt-32.rc
	$(BRC32) -DDEBUG=0 -D__BORLANDC__ -r -i..\inc -fo build\Borland\Win32\watt-32.res watt-32.rc

build/clang/32bit/release/watt-32.res: watt-32.rc
	rc -nologo -DRC_DATE="$(DATE)" -DDEBUG=0 -D__clang__ -DBITS=32 -Fo build/clang/32bit/release/watt-32.res watt-32.rc

build/clang/32bit/debug/watt-32.res: watt-32.rc
	rc -nologo -DRC_DATE="$(DATE)" -DDEBUG=1 -D__clang__ -DBITS=32 -Fo build/clang/32bit/debug/watt-32.res watt-32.rc

build/clang/64bit/release/watt-32.res: watt-32.rc
	rc -nologo -DRC_DATE="$(DATE)" -DDEBUG=0 -D__clang__ -DBITS=64 -Fo build/clang/64bit/release/watt-32.res watt-32.rc

build/clang/64bit/debug/watt-32.res: watt-32.rc
	rc -nologo -DRC_DATE="$(DATE)" -DDEBUG=1 -D__clang__ -DBITS=64 -Fo build/clang/64bit/debug/watt-32.res watt-32.rc

build\lcc\watt-32.res: watt-32.rc
	lrc -DDEBUG=0 -D__LCC__ -i..\inc -obuild\lcc\watt-32.res watt-32.rc

build/MinGW32/watt-32.res: watt-32.rc
	windres -DRC_DATE="$(DATE)" --target=pe-i386 -D__MINGW32__ -DDEBUG=0 -O coff -o $@ -i watt-32.rc

build/MinGW64/32bit/watt-32.res: watt-32.rc
	windres -DRC_DATE="$(DATE)" -DBITS=32 --target=pe-i386 -D__MINGW64__ -DDEBUG=0 -O coff -o $@ -i watt-32.rc

build/MinGW64/64bit/watt-32.res: watt-32.rc
	windres -DRC_DATE="$(DATE)" -DBITS=64 --target=pe-x86-64 -D__MINGW64__ -DDEBUG=0 -O coff -o $@ -i watt-32.rc

build/CygWin/32bit/watt-32.res: watt-32.rc
	windres -DRC_DATE="$(DATE)" -DBITS=32 -I../inc -DDEBUG=0 -D__CYGWIN__ -O coff -o $@ -i watt-32.rc

build/CygWin/64bit/watt-32.res: watt-32.rc
	windres -DRC_DATE="$(DATE)" -DBITS=64 -I../inc -DDEBUG=0 -D__CYGWIN__ -O coff -o $@ -i watt-32.rc

build\pellesc\32bit\watt-32.res: watt-32.rc
	porc -DDEBUG=0 -D__POCC__ -DBITS=32 -I..\inc -Fobuild\pellesc\32bit\watt-32.res watt-32.rc

build\pellesc\64bit\watt-32.res: watt-32.rc
	porc -DDEBUG=0 -D__POCC__ -DBITS=64 -I..\inc -Fobuild\pellesc\64bit\watt-32.res watt-32.rc

build\visualc\32bit\release\watt-32.res: watt-32.rc
	rc -nologo -DDEBUG=0 -D_MSC_VER -DBITS=32 -Fo build\visualc\32bit\release\watt-32.res watt-32.rc

build\visualc\32bit\debug\watt-32.res: watt-32.rc
	rc -nologo -DDEBUG=1 -D_MSC_VER -DBITS=32 -Fo build\visualc\32bit\debug\watt-32.res watt-32.rc

build\visualc\64bit\release\watt-32.res: watt-32.rc
	rc -nologo -DDEBUG=0 -D_MSC_VER -DBITS=64 -Fo build\visualc\64bit\release\watt-32.res watt-32.rc

build\visualc\64bit\debug\watt-32.res: watt-32.rc
	rc -nologo -DDEBUG=1 -D_MSC_VER -DBITS=64 -Fo build\visualc\64bit\debug\watt-32.res watt-32.rc

build\watcom\win32\watt-32.res: watt-32.rc
	*wrc -dDEBUG=0 -D__WATCOMC__ -q -r -zm -fo=build\watcom\win32\watt-32.res watt-32.rc

#
# Rules for creating 'cflagsbf.h'. A file with a C-array of the 'CFLAGS' used.
# Included in 'version.c'.
#
# $(W32_BIN2C) should be set by .\configur.bat to point to either
# ..\util\bin2c.exe or ..\util\win32\bin2c.exe.
#
# And for GNU-make, $(W32_BIN2C_) should be set by .\configur.bat to point to either
# ../util/bin2c.exe or ../util/win32/bin2c.exe.
#
# PS. 'cflagsbf.h' was previously named 'cflags_buf.h'. But that may cause troubles
#     on plain DOS with only 8+3 files.
#
build\build\borland\small\cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS)                     > build\borland\small\cflagsbf.h

build\borland\large\cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS)                     > build\borland\large\cflagsbf.h

build\borland\flat\cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS)                     > build\borland\flat\cflagsbf.h

build\borland\win32\cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS)                     > build\borland\win32\cflagsbf.h

build\highc\cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS)                     > build\highc\cflagsbf.h

build\ladsoft\cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C)            - > build\ladsoft\cflagsbf.h

build\lcc\cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C)            - > build\lcc\cflagsbf.h

build\pellesc\32bit\cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C)            - > build\pellesc\32bit\cflagsbf.h

build\pellesc\64bit\cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C)            - > build\pellesc\64bit\cflagsbf.h

build\visualc\32bit\release\cflagsbf.h: $(C_ARGS)
	- echo $(CFLAGS) | $(W32_BIN2C)          - > build\visualc\32bit\release\cflagsbf.h

build\visualc\32bit\debug\cflagsbf.h: $(C_ARGS)
	- echo $(CFLAGS) | $(W32_BIN2C)          - > build\visualc\32bit\debug\cflagsbf.h

build\visualc\64bit\release\cflagsbf.h: $(C_ARGS)
	- echo $(CFLAGS) | $(W32_BIN2C)          - > build\visualc\64bit\release\cflagsbf.h

build\visualc\64bit\debug\cflagsbf.h: $(C_ARGS)
	- echo $(CFLAGS) | $(W32_BIN2C)          - > build\visualc\64bit\debug\cflagsbf.h

@ifdef DJGPP MINGW32 MINGW64 CYGWIN32 CYGWIN64
#
# Nmake doesn't like these rules. Hence inside this block.
#
build/CygWin/32bit/cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C_)           - > build/CygWin/32bit/cflagsbf.h

build/CygWin/64bit/cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C_)           - > build/CygWin/64bit/cflagsbf.h

build/MinGW32/cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C_)           - > build/MinGW32/cflagsbf.h

build/MinGW64/32bit/cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C_)           - > build/MinGW64/32bit/cflagsbf.h

build/MinGW64/64bit/cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C_)           - > build/MinGW64/64bit/cflagsbf.h
@endif

@ifdef WATCOM
build\watcom\small\cflagsbf.h: $(C_ARGS)
	$(%W32_BIN2C) $(C_ARGS)                    > build\watcom\small\cflagsbf.h

build\watcom\large\cflagsbf.h: $(C_ARGS)
	$(%W32_BIN2C) $(C_ARGS)                    > build\watcom\large\cflagsbf.h

build\watcom\flat\cflagsbf.h: $(C_ARGS)
	$(%W32_BIN2C) $(C_ARGS)                    > build\watcom\flat\cflagsbf.h

build\watcom\win32\cflagsbf.h: $(C_ARGS)
	$(%W32_BIN2C) $(C_ARGS)                    > build\watcom\win32\cflagsbf.h

build\watcom\small32\cflagsbf.h: $(C_ARGS)
	$(%W32_BIN2C) $(C_ARGS)                    > build\watcom\small32\cflagsbf.h
@endif

@ifdef CLANG
build/clang/32bit/release/cflagsbf.h \
build/clang/32bit/debug/cflagsbf.h   \
build/clang/64bit/release/cflagsbf.h \
build/clang/64bit/debug/cflagsbf.h:
	$(W32_BIN2C_) $(C_ARGS) > $@
@endif

@ifdef DJGPP MINGW32 MINGW64 CYGWIN32 CYGWIN64

DEP_REPLACE = sed -e 's/\(.*\)\.o: /\n$$(OBJDIR)\/\1.o: /'

@ifdef CYGWIN32 CYGWIN64
  #
  # Change the 'f:' drive letter for your CygWin installation:
  #
  DEP_REPLACE += -e 's@/cygdrive/f@f:@'
@endif

DEP_FILE = $(OBJDIR)/watt-32.dep

depend: $(OBJDIR)/cflags.h
	$(CC) -MM $(CFLAGS) $(C_SOURCE) | $(DEP_REPLACE) > $(DEP_FILE)

-include $(DEP_FILE)

@endif
