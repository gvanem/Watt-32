#!/usr/bin/env python

"""A Python replacement for the appveyor-script.bat.
"""

from __future__ import print_function
import sys, os, time

# These can be rather slow:
#
URLs = { 'djgpp':   'http://www.watt-32.net/CI/dj-win.zip',
         'watcom':  'http://www.watt-32.net/CI/watcom20.zip',
         'borland': 'http://www.watt-32.net/CI/borland.zip',
         'clang':   'http://www.watt-32.net/CI/llvm-installer.exe',
       }

builders = [ "visualc", "clang", "mingw32", "mingw64", "borland", "djgpp", "watcom" ]

have_colorama = 0

#
# When testing locally, there should be no '%APPVEYOR_PROJECT_NAME%'
#
if os.getenv ("APPVEYOR_PROJECT_NAME"):
  local_test = 0
  echo = 'c:\\msys64\\usr\\bin\\echo.exe -en'
else:
  local_test = 1
  echo = os.getenv('MSYS2_ROOT') + r'\usr\bin\echo.exe -en'

try:
  from colorama import init, Fore, Style  # Fails on AppVeyour
  init()
  colour_off    = Style.RESET_ALL
  colour_red    = Fore.RED + Style.BRIGHT
  colour_yellow = Fore.YELLOW + Style.BRIGHT
  have_colorama = 1

except ImportError:
  colour_off    = r'\e[0m'
  colour_yellow = r'\e[1;33m'
  colour_red    = r'\e[1;31m'

#
# Why so hard to get colours on AppVeyor?
#
def cprint (s):
  s = '%s%s%s' % (colour_yellow, s, colour_off)
  global have_colorama
  if have_colorama:
    print (s, end="")
  else:
    os.system ('%s "%s"' % (echo, s))

def Fatal (s):
  cprint ("%s%s" % (colour_red, s))
  sys.exit (1)

#
# Create a .bat file in '%TEMP' and run it via 'cmd.exe /c file.bat'
#
def write_and_run_bat (fname, content, args=""):
  bat = os.getenv("TEMP") + "\\" + fname
  f = open (bat, 'wt+')
  f.write (':: Generated by %s at %s\n' % (__file__, time.ctime()))
  for l in content:
    f.write (l + '\n')
  f.close()
  return os.system ('cmd.exe /C %s %s' % (bat, args))

#
# Env-vars common to 'build_src' and 'build_bin' and 'build_tests'
#
def get_env_vars_common():
  env_var = {}

  global local_test
  if local_test:
    watt_root = os.getenv ("WATT_ROOT")
    if not watt_root:
       Fatal ("WATT_ROOT not set!")
  else:
    watt_root = "c:\projects\watt-32"

  cpu     = os.getenv ("CPU", "x86")
  builder = os.getenv ("BUILDER", None)

  if not builder:
    Fatal ("BUILDER not set!")

  if not builder in builders:
    Fatal ("Illegal BUILDER: '%s'." % builder)

  env_var['APPVEYOR_BUILD_FOLDER'] = watt_root
  env_var['LOCAL_TEST'] = local_test
  env_var['WATT_ROOT']  = watt_root
  env_var['BUILDER']    = builder
  env_var['CPU']        = cpu
  env_var['CL']         = ''
  env_var['MODEL']      = os.getenv ('MODEL', 'none')
  env_var['PATH']       = os.getenv ('PATH')

  if cpu == 'x86':
    env_var['BITS'] = '32'
  else:
    env_var['BITS'] = '64'

  #
  # Download stuff and install packages here:
  #
  env_var['CI_ROOT'] = env_var['APPVEYOR_BUILD_FOLDER'] + r'\CI-temp'

  if builder == 'mingw32' or builder == 'mingw64':
    env_var['MINGW32'] = watt_root.replace ("\\","/")
    env_var['MINGW64'] = watt_root.replace ("\\","/")

  #
  # Set the dir for djgpp cross-environment.
  # Use forward slashes for this. Otherwise 'sh' + 'make' will get confused.
  # 7z can create only 1 level of missing directories. So a '%CI_ROOT%\djgpp' will not work
  #
  if builder == 'djgpp':
    env_var['DJGPP']     = env_var['CI_ROOT'].replace ("\\","/")
    env_var['DJ_PREFIX'] = env_var['DJGPP'] + '/bin/i586-pc-msdosdjgpp-'

  if builder == 'watcom':
    env_var['WATCOM']      = env_var['CI_ROOT']
    env_var['NT_INCLUDE']  = env_var['WATCOM'] + r'\h;' + env_var['WATCOM'] + r'\h\nt'
    env_var['DOS_INCLUDE'] = env_var['WATCOM'] + r'\h'
    env_var['PATH']       =  env_var['WATCOM'] + r'\binnt;' + env_var['PATH']

  if builder == 'borland':
    env_var['BCCDIR']  = env_var['CI_ROOT']
    env_var['INCLUDE'] = env_var['BCCDIR'] + r'\include\windows;' + env_var['BCCDIR'] + r'\include\windows\sdk'
    env_var['CBUILDER_IS_LLVM_BASED'] = '1'
    env_var['PATH'] = env_var['BCCDIR'] + r'\bin;' + env_var['PATH']

  if builder == 'clang' and cpu == 'x86':
    env_var['PATH'] = r'c:\Program Files\LLVM\bin;' + env_var['PATH']

  env_var['WSOCK_TRACE_LEVEL'] = '0'
  env_var['USE_WSOCK_TRACE']   = '0'

  return env_var

#
# Env-vars for 'build_bin':
#
def get_env_vars_bin():
  bin_vars = {}

  bin_vars['PROGS_DJ'] = 'bping.exe ping.exe finger.exe ident.exe htget.exe tcpinfo.exe tracert.exe country.exe'
  bin_vars['PROGS_VC'] = 'ping.exe finger.exe tcpinfo.exe host.exe htget.exe tracert.exe con-test.exe gui-test.exe lpq.exe lpr.exe ntime.exe whois.exe ident.exe country.exe'
  bin_vars['PROGS_MW'] = bin_vars['PROGS_VC']    #  MinGW-w64
  bin_vars['PROGS_CL'] = bin_vars['PROGS_VC']    #  clang-cl Win32
  bin_vars['PROGS_BC'] = bin_vars['PROGS_VC']    #  Borland/CBuilder Win32

  bin_vars['PROGS_WC_WIN']     = 'ping.exe htget.exe finger.exe tcpinfo.exe con-test.exe gui-test.exe htget.exe tracert.exe whois.exe'
  bin_vars['PROGS_WC_LARGE']   = 'ping.exe htget.exe finger.exe tcpinfo.exe htget.exe whois.exe'
  bin_vars['PROGS_WC_FLAT']    = bin_vars['PROGS_WC_LARGE']
  bin_vars['PROGS_WC_SMALL32'] = bin_vars['PROGS_WC_LARGE']
  return bin_vars


#
# The progress callback for 'urllib.urlretrieve()'.
#
def url_progress (blocks, block_size, total_size):
  if blocks:
    percent = 100 * (blocks * block_size) / total_size
    kBbyte_so_far = (blocks * block_size) / 1024
    cprint ("Got %d kBytes (%u%%)\r" % (kBbyte_so_far, percent))

#
# Check if a local 'fname' exist. Otherwise download it from 'url'
# and unzip it using '7z'.
#
def download_and_install (fname, url, is_clang_x86=False):
  if os.path.exists(fname):
    cprint ("A local %s already exist.\n" % fname.replace('\\','/'))
    return 0

  try:
    from urllib import urlretrieve as url_get
  except ImportError:
    from urllib.request import urlretrieve as url_get

  cprint ("url_get: %s -> %s.\n" % (url, fname))
  url_get (url, filename = fname, reporthook = url_progress)
  print ("")

  directory = os.path.dirname (fname)

  if is_clang_x86:
    global local_test
    if local_test:
      cprint ('Not installing 32-bit LLVM using "cd %s & cmd.exe /C start /wait llvm-installer.exe /S"\n' % directory)
    else:
      cprint ('Installing 32-bit LLVM...')
      os.system ('cd %s & cmd.exe /C start /wait llvm-installer.exe /S' % directory)
      os.system ('clang-cl -v')

  else:
    cprint ('Unzipping %s to %s.\n' % (fname, directory))
    r = os.system ('7z x -y -o%s %s > NUL' % (directory, fname))
    if r != 0:
      Fatal ("7z failed: %d." % r)


def generate_oui():
  cprint ("Generating 'src/oui-generated.c'.")
  r = os.system ('python.exe make-oui.py > oui-generated.c')
  cprint ('--------------------------------------------------------------------------------------------------\n')
  return r

#
# Print some usage.
#
def show_help():
  print ("%sUsage: %s [build_src | build_bin | build_tests | fake_test]" % (__doc__, __file__))
  sys.exit (0)

def get_env_string (envs):
  ret = ""
  for e in iter(envs):
     ret += 'set %s=%s\n' % (e, envs[e])
  return ret

#
# Print a colourised message and return the makefile command for 'build_src':
#
def get_src_make_command (builder, cpu, model=""):
  bits = '32'
  if cpu == 'x64':
    bits = '64'

  if builder == 'visualc':
     cprint ("[%s]: Building release:\n" % cpu)
     return 'nmake -nologo -f visualc-release_%s.mak' % bits

  if builder == 'clang':
     cprint ("[%s]: Building release:\n" % cpu)
     return 'make -f clang-release_%s.mak' % bits

  if builder == 'mingw32':
     cprint ("[%s]: Building:\n" % cpu)
     return 'make -f MinGW32.mak'

  if builder == 'mingw64':
     cprint ("[%s]: Building:\n" % cpu)
     return 'make -f MinGW64_%s.mak' % bits

  if builder == 'djgpp':
     cprint ("[%s]: Building:\n" % cpu)
     return 'make -f djgpp.mak'

  if builder == 'borland':
     cprint ("[%s]: Building:\n" % cpu)
     return '%s\\bin\\make -f bcc_w.mak' % env_vars['BCCDIR']

  if builder == 'watcom':
    if model == 'win32':
      cprint ("[%s]: Building for Watcom/Win32:\n" % cpu)
      return 'wmake -h -f watcom_w.mak'

    if model == 'flat':
      cprint ("[%s]: Building for Watcom/flat:\n" % cpu)
      return 'wmake -h -f watcom_f.mak'

    if model == 'large':
      cprint ("[%s]: Building for Watcom/large:\n" % cpu)
      return 'wmake -h -f watcom_l.mak'

    Fatal ("[%s]: BUILDER Watcom needs a MODEL!" % cpu)

  Fatal ("[%s]: I did not expect this!" % cpu)


#
# Print a colourised message and return the makefile command for 'build_bin'.
# Return the 'PROGS_x' and makefile name.
#
def get_bin_make_command (env_vars):
  builder = env_vars['BUILDER']
  cpu     = env_vars['CPU']

  if builder == 'djgpp':
    cprint ('[%s]: Building PROGS_DJ=%s:' % (cpu, env_vars['PROGS_DJ']))
    return 'make -f djgpp_win.mak DPMI_STUB=0', env_vars['PROGS_DJ']

  if builder == 'visualc':
     cprint ("[%s]: Building PROGS_VC=%s\n" % (cpu, env_vars['PROGS_VC']))
     return 'nmake -nologo -f visualc.mak', env_vars['PROGS_VC']

  if builder == 'mingw64':
     cprint ("[%s]: Building PROGS_MW=%s\n" % (cpu, env_vars['PROGS_MW']))
     return 'make -f mingw64.mak', env_vars['PROGS_MW']

  if builder == 'clang':
     cprint ("[%s]: Building PROGS_CL=%s\n" % (cpu, env_vars['PROGS_CL']))
     return 'make -f clang.mak', env_vars['PROGS_CL']

  if builder == 'borland':
     cprint ("[%s]: Building PROGS_BC=%s\n" % (cpu, env_vars['PROGS_BC']))
     return '%s\\bin\\make -f bcc_win.mak' % env_vars['BCCDIR'], env_vars['PROGS_BC']

  if builder == 'watcom':
    model =  env_vars['MODEL']
    if model == 'win32':
      cprint ('[%s]: watcom/Win32: Building PROGS_WC_WIN=%s' % (cpu, env_vars['PROGS_WC_WIN']))
      return 'wmake -h -f wc_win.mak', env_vars['PROGS_WC_WIN']

    if model == 'flat':
      cprint ('[%s]: watcom/flat: Building PROGS_WC_FLAT=%s' % (cpu, env_vars['PROGS_WC_FLAT']))
      return 'wmake -h -f causeway.mak', env_vars['PROGS_WC_FLAT']

    if model == 'large':
      cprint ('[%s]: watcom/large: Building PROGS_WC_LARGE=%s' % (cpu, env_vars['PROGS_WC_LARGE']))
      return 'wmake -h -f watcom.mak', env_vars['PROGS_WC_LARGE']

    Fatal ("[%s]: BUILDER Watcom needs a MODEL!" % cpu)

  cprint ("[%s]: No 'build_bin' for 'BUILDER=%s' yet." % (cpu, builder))
  return '', ''

#
# Concatinate 2 dictionaries:
#   https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression/26853961#26853961
#
def merge_dicts (a, b):
  r = a.copy()   # start with a's keys and values
  r.update(b)    # modifies r with b's keys and values & returns None
  return r

def run_test (prog, args=[]):
  if not os.path.exists(prog):
    cprint ("Test program '%s' failed to link! -----------------------------------------------\n" % cmd)
    return 1
  cmd = prog + ' ' + ' '.join(args)
  cprint ("Running test '%s' ---------------------------------------------------------------\n" % cmd)
  return os.system (cmd)

def main():
  if len(sys.argv) != 2 or \
     sys.argv[1] not in ["build_src", "build_bin", "build_tests", "fake_test"]:
    show_help()

  env_vars = get_env_vars_common()

  base = os.path.basename(__file__)
  file = env_vars['APPVEYOR_BUILD_FOLDER'] + '\\' + base

  if not os.path.exists(base):
    Fatal ("Run %s from it's directory." % file)

  os.system ('md %s 2> NUL' % env_vars['CI_ROOT'])

  builder = env_vars['BUILDER']
  cpu     = env_vars['CPU']
  model   = env_vars['MODEL']
  cmd     = sys.argv[1]

  cprint ("Doing '%s' for 'BUILDER=%s'" % (cmd, builder))
  if builder == 'watcom':
    cprint (", 'MODEL=%s'\n" % model)  # Only 'watcom' has a '%MODEL%' set in 'appveoyr.yml'
  else:
    cprint ('\n')

  try:
    installer = env_vars['CI_ROOT'] + '\\' + os.path.basename (URLs[builder])
    if builder == 'clang' and cpu == 'x86':
      download_and_install (installer, URLs[builder], True)
    else:
      download_and_install (installer, URLs[builder])
  except KeyError:
    # No need to install anything for this '%BUILDER%'
    pass

  if cmd == 'fake_test':
    r = write_and_run_bat ("fake_test.bat",
                           [ '@echo off',
                             'setlocal',
                             get_env_string(env_vars),
                             'echo BUILDER: %BUILDER%',
                             'echo CPU:     %CPU%',
                             'echo MODEL:   %MODEL%',
                             'echo arg1:    "%1"'
                           ],
                           sys.argv[1])

  elif cmd == 'build_src':
    os.chdir ('src')
    if generate_oui() == 0:
      env_vars['CL'] = '-DHAVE_OUI_GENERATATED_C'

    write_and_run_bat ("build_src_1.bat",
                       [ '@echo off',
                         'setlocal',
                         'prompt $P$G',
                         get_env_string (env_vars),
                         'call configur.bat %s' % builder
                       ] )

    r = write_and_run_bat ("build_src_2.bat",
                           [ '@echo off',
                             'setlocal',
                             'prompt $P$G',
                             get_env_string (env_vars),
                             get_src_make_command (builder, env_vars['CPU'], env_vars['MODEL'])
                           ] )

  elif cmd == 'build_bin':
    os.chdir ('bin')

    bin_vars = get_env_vars_bin()
    bin_make, bin_progs = get_bin_make_command (merge_dicts(env_vars, bin_vars))
    if bin_progs == '':
      return 0

    os.system ('rm -f %s' % bin_progs)

    r = write_and_run_bat ("build_bin.bat",
                           [ '@echo off',
                             'setlocal',
                             'prompt $P$G',
                             get_env_string (env_vars),
                             get_env_string (bin_vars),
                             '%s %s' % (bin_make, bin_progs)
                           ] )

  elif cmd == 'build_tests':
    r = write_and_run_bat ("build_tests.bat",
                           [ '@echo off',
                             'prompt $P$G',
                             get_env_string (env_vars),
                             r'cd src\tests',
                             r'call configur.bat %BUILDER%',
                             r'if %BUILDER%. == borland.  make -f bcc_w.mak',
                             r'if %BUILDER%. == djgpp.    make -f djgpp.mak',
                             r'if %BUILDER%. == clang.    make -f clang_%BITS%.mak',
                             r'if %BUILDER%. == mingw64.  make -f MinGW64_%BITS%.mak',
                             r'if %BUILDER%. == visualc.  make -f visualc_%BITS%.mak',
                             r'if %BUILDER%. == watcom. (',
                             r'   if %MODEL%. == large. make -f watcom_l.mak',
                             r'   if %MODEL%. == flat.  make -f watcom_f.mak',
                             r'   if %MODEL%. == win32. make -f watcom_w.mak',
                             ')',
                           ] )
    os.chdir ('src\\tests')
    run_test ('cpu.exe')
    run_test ('cpuspeed.exe', ['1', '1'])
    run_test ('swap.exe')
    run_test ('chksum.exe', ['-s'])

  if r:
    cprint ("r: %d" % r)

if __name__ == '__main__':
  main()

